
{ This unit was generated by DCocoR.  
  Any code in this file that you edit manually will be over-written when the file is regenerated.
}

unit Zc;

interface

uses Classes,CocoAncestor,
          Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication ;

type


  TZcScanner = class(TCocoRScanner)
  public
    procedure SkipIgnoreSet; override;
    procedure ScanSym(state: Integer; var sym: Integer); override;
    function SkipComments(ind: Integer): Boolean; override;
  end;


  TZc = class(TCocoRGrammar)
  private             
    IsInIdent,IsInInvokeArg : boolean;
    CurrentFunction : TZcOpFunctionUserDefined;
    procedure CleanUp;
    procedure ZError(const S : string);
    procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
    procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
    function IsConst : boolean;
    function GetInitializer : TZcOpFunctionUserDefined;
    
  protected

    procedure _ZcFuncRest(Typ : TZcDataType; const Name : string; IsPrivate,IsInline : boolean);
    procedure _FormalParams;
    procedure _ZcFuncBody;
    procedure _Zc;
    procedure _ConstantDeclarationList(IsPrivate : boolean);
    procedure _Type(var Typ : TZcDataType);
    procedure _GlobalVarDecl(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
    procedure _Block(var OutOp : TZcOp);
    procedure _Statement(var OutOp : TZcOp);
    procedure _Par;
    procedure _LocalVarDecl(var OutOp : TZcOp);
    procedure _LocalVar(Typ : TZcDataType; var OutOp : TZcOp);
    procedure _Init(var OutOp : TZcOp);
    procedure _GlobalVarRest(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
    procedure _GlobalVar(Typ : TZcDataType; IsPrivate : boolean);
    procedure _Expr(var OutOp : TZcOp);
    procedure _Argument(var OutOp : TZcOp);
    procedure _SimpleType(var Typ : TZcDataType);
    procedure _ConstantDeclaration(var Typ : TZcDataType; IsPrivate : boolean);
    procedure _EmbeddedStatement(var OutOp : TZcOp);
    procedure _StatementExpr(var OutOp : TZcOp);
    procedure _SwitchSection(SwitchOp : TZcOpSwitch);
    procedure _ForInit(var OutOp : TZcOp);
    procedure _ForInc(var OutOp : TZcOp);
    procedure _Unary(var OutOp : TZcOp);
    procedure _AssignOp(var Kind : TZcAssignType);
    procedure _SwitchLabel(var OutOp : TZcOp);
    procedure _OrExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _AndExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitOrExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitXorExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitAndExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _EqlExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _RelExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _ShiftExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _AddExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _MulExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _Primary(var OutOp : TZcOp);
    procedure _InvokeArgument(var OutOp : TZcOp; Ci : TZComponentInfo);
    procedure _ReinterpretCast(var OutOp : TZcOp);
    procedure _InlineComponent(var OutOp : TZcOp);
    procedure _Literal(var Typ : TZcDataType);

  public
           
    ZFunctions : TObjectList;
    SymTab : TSymbolTable;
    AllowInitializer : boolean;
    GlobalNames : TObjectList;
    TempCounter : integer;
    ZApp : TZApplication;
    InitializerFunction : TZcOpFunctionUserDefined;
    destructor Destroy; override;
    procedure CheckHomograph(var sym: Integer); override;

    (* procedure ProcessPragmas; override; *)
    function  ErrorMessage(ErrorType,ErrorCode: Integer; const data: string): String; override;
    function  TokenToString(n: Integer): String; override;
    function  CreateScanner: TBaseScanner; override;
    function Execute: Boolean; override;

    constructor Create(AOwner: TComponent); override;

  end;

implementation

const

	intConSym = 1;	realConSym = 2;	stringConSym = 3;	identSym = 4;	andSym = 5;
	assgnSym = 6;	colonSym = 7;	commaSym = 8;	decSym = 9;	divSym = 10;
	dotSym = 11;	eqSym = 12;	gtSym = 13;	gteSym = 14;	incSym = 15;
	lbraceSym = 16;	lbrackSym = 17;	lparSym = 18;	lshiftSym = 19;	ltSym = 20;
	lteSym = 21;	minusSym = 22;	modSym = 23;	neqSym = 24;	notSym = 25;
	orSym = 26;	plusSym = 27;	rbraceSym = 28;	rbrackSym = 29;	rparSym = 30;
	rshiftSym = 31;	scolonSym = 32;	tildeSym = 33;	timesSym = 34;	xorSym = 35;
	MaterialSym = 36;	SoundSym = 37;	ShaderSym = 38;	BitmapSym = 39;	MeshSym = 40;
	CameraSym = 41;	FontSym = 42;	SampleSym = 43;	FileSym = 44;	ComponentSym = 45;
	privateSym = 46;	inlineSym = 47;	voidSym = 48;	refSym = 49;	floatSym = 50;
	intSym = 51;	byteSym = 52;	stringSym = 53;	modelSym = 54;	xptrSym = 55;
	mat_fourSym = 56;	vec_twoSym = 57;	vec_threeSym = 58;	vec_fourSym = 59;	constSym = 60;
	ifSym = 61;	elseSym = 62;	switchSym = 63;	whileSym = 64;	doSym = 65;
	forSym = 66;	breakSym = 67;	continueSym = 68;	returnSym = 69;	_plus_equalSym = 70;
	_minus_equalSym = 71;	_star_equalSym = 72;	_slash_equalSym = 73;	_bar_equalSym = 74;	_less_less_equalSym = 75;
	_greater_greater_equalSym = 76;	_and_equalSym = 77;	caseSym = 78;	defaultSym = 79;	_querySym = 80;
	_bar_barSym = 81;	_and_andSym = 82;	reinterpret_underscorecastSym = 83;	_atSym = 84;	nullSym = 85;
	_NOSYMB = 86;	_slash_starSym = 87;	_slash_slashSym = 88;

var ZcSymSets: TSetArray;


var
  ZcST: TStartTable = nil;
  ZcLiterals: TStringList = nil;

{ TZcScanner }

procedure TZcScanner.ScanSym(state: Integer; var sym: Integer);
begin
 while True do
 begin
  NextCh;
  case state of
	 1:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F'))or((CurrInputCh>='a')and(CurrInputCh<='f')) then
		  state := 2
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 2:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F'))or((CurrInputCh>='a')and(CurrInputCh<='f')) then
		else begin
		  sym := intConSym;
		  Exit;
		end;
	 3:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 4
		else begin
		  sym := realConSym;
		  Exit;
		end;
	 4:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 6
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 5
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 5:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 6
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 6:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := realConSym;
		  Exit;
		end;
	 7:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 8
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 8:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 9
		else begin
		  sym := realConSym;
		  Exit;
		end;
	 9:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 11
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 10
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	10:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 11
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	11:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := realConSym;
		  Exit;
		end;
	12:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 14
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 13
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	13:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 14
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	14:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := realConSym;
		  Exit;
		end;
	15:
		begin
		  sym := realConSym;
		  Exit;
		end;
	16:
		if not((CurrInputCh=#10)or(CurrInputCh=#13)or(CurrInputCh='"')or(CurrInputCh='\')) then
		else if (CurrInputCh = '"') then
		  state := 17
		else if (CurrInputCh = '\') then
		  state := 44
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	17:
		begin
		  sym := stringConSym;
		  Exit;
		end;
	18:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_')or((CurrInputCh>='a')and(CurrInputCh<='z')) then
		else begin
		  sym := identSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	19:
		begin
		  sym := colonSym;
		  Exit;
		end;
	20:
		begin
		  sym := commaSym;
		  Exit;
		end;
	21:
		begin
		  sym := decSym;
		  Exit;
		end;
	22:
		begin
		  sym := eqSym;
		  Exit;
		end;
	23:
		begin
		  sym := gteSym;
		  Exit;
		end;
	24:
		begin
		  sym := incSym;
		  Exit;
		end;
	25:
		begin
		  sym := lbraceSym;
		  Exit;
		end;
	26:
		begin
		  sym := lbrackSym;
		  Exit;
		end;
	27:
		begin
		  sym := lparSym;
		  Exit;
		end;
	28:
		begin
		  sym := lteSym;
		  Exit;
		end;
	29:
		begin
		  sym := modSym;
		  Exit;
		end;
	30:
		begin
		  sym := neqSym;
		  Exit;
		end;
	31:
		begin
		  sym := rbraceSym;
		  Exit;
		end;
	32:
		begin
		  sym := rbrackSym;
		  Exit;
		end;
	33:
		begin
		  sym := rparSym;
		  Exit;
		end;
	34:
		begin
		  sym := scolonSym;
		  Exit;
		end;
	35:
		begin
		  sym := tildeSym;
		  Exit;
		end;
	36:
		begin
		  sym := xorSym;
		  Exit;
		end;
	37:
		begin
		  sym := _slash_starSym;
		  Exit;
		end;
	38:
		begin
		  sym := _slash_slashSym;
		  Exit;
		end;
	39:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '.') then
		  state := 7
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 12
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := intConSym;
		  Exit;
		end;
	40:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 39
		else if (CurrInputCh='X')or(CurrInputCh='x') then
		  state := 1
		else if (CurrInputCh = '.') then
		  state := 7
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 12
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := intConSym;
		  Exit;
		end;
	41:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 3
		else begin
		  sym := dotSym;
		  Exit;
		end;
	42:
		if (CurrInputCh = '=') then
		  state := 22
		else begin
		  sym := assgnSym;
		  Exit;
		end;
	43:
		if (CurrInputCh = '=') then
		  state := 30
		else begin
		  sym := notSym;
		  Exit;
		end;
	44:
		if (CurrInputCh='"')or(CurrInputCh='''')or(CurrInputCh='\')or(CurrInputCh='n') then
		  state := 16
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	45:
		begin
		  sym := _plus_equalSym;
		  Exit;
		end;
	46:
		begin
		  sym := _minus_equalSym;
		  Exit;
		end;
	47:
		begin
		  sym := _star_equalSym;
		  Exit;
		end;
	48:
		begin
		  sym := _slash_equalSym;
		  Exit;
		end;
	49:
		begin
		  sym := _bar_equalSym;
		  Exit;
		end;
	50:
		begin
		  sym := _less_less_equalSym;
		  Exit;
		end;
	51:
		begin
		  sym := _greater_greater_equalSym;
		  Exit;
		end;
	52:
		begin
		  sym := _and_equalSym;
		  Exit;
		end;
	53:
		begin
		  sym := _querySym;
		  Exit;
		end;
	54:
		begin
		  sym := _bar_barSym;
		  Exit;
		end;
	55:
		begin
		  sym := _and_andSym;
		  Exit;
		end;
	56:
		begin
		  sym := _atSym;
		  Exit;
		end;
	57:
		if (CurrInputCh = '=') then
		  state := 52
		else if (CurrInputCh = '&') then
		  state := 55
		else begin
		  sym := andSym;
		  Exit;
		end;
	58:
		if (CurrInputCh = '-') then
		  state := 21
		else if (CurrInputCh = '=') then
		  state := 46
		else begin
		  sym := minusSym;
		  Exit;
		end;
	59:
		if (CurrInputCh = '*') then
		  state := 37
		else if (CurrInputCh = '/') then
		  state := 38
		else if (CurrInputCh = '=') then
		  state := 48
		else begin
		  sym := divSym;
		  Exit;
		end;
	60:
		if (CurrInputCh = '=') then
		  state := 23
		else if (CurrInputCh = '>') then
		  state := 65
		else begin
		  sym := gtSym;
		  Exit;
		end;
	61:
		if (CurrInputCh = '+') then
		  state := 24
		else if (CurrInputCh = '=') then
		  state := 45
		else begin
		  sym := plusSym;
		  Exit;
		end;
	62:
		if (CurrInputCh = '<') then
		  state := 66
		else if (CurrInputCh = '=') then
		  state := 28
		else begin
		  sym := ltSym;
		  Exit;
		end;
	63:
		if (CurrInputCh = '=') then
		  state := 49
		else if (CurrInputCh = '|') then
		  state := 54
		else begin
		  sym := orSym;
		  Exit;
		end;
	64:
		if (CurrInputCh = '=') then
		  state := 47
		else begin
		  sym := timesSym;
		  Exit;
		end;
	65:
		if (CurrInputCh = '=') then
		  state := 51
		else begin
		  sym := rshiftSym;
		  Exit;
		end;
	66:
		if (CurrInputCh = '=') then
		  state := 50
		else begin
		  sym := lshiftSym;
		  Exit;
		end;
  
    else begin
      if CurrInputCh=#0 then
           sym := _EOFSYMB
      else sym := _NOSYMB;
      Exit;
    end;
  end;
 end;
end;


procedure TZcScanner.SkipIgnoreSet;
begin
  while (CurrInputCh = ' ') or 
    ( (CurrInputCh=#9)or(CurrInputCh=#10)or(CurrInputCh=#13) )
  do NextCh;
end;


function TZcScanner.SkipComments(ind: Integer): Boolean;
begin
  Result := True;
  case ind of
    _slash_starSym: SkipCommentTo('*/');
    _slash_slashSym: SkipCommentTo(#10);

    else Result := False;
  end;
end;



{ TZc }

                   

procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
begin
  ZError(Msg + ' ' + Data);
end;

procedure TZc.CheckHomograph(var sym: Integer);
begin
  //Only Homographs are name of component datatypes
  //If inside identifier "x.y.z" then let it refer to identifier instead
  if IsInIdent or IsInInvokeArg then
    sym := identSym;
end;

destructor TZc.Destroy;
begin
  inherited;
  CleanUp;
end;

procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
begin
  if Op=nil then
  begin
    if SwitchOp.HasDefault then
      ZError('Only one default statement is allowed.');
    SwitchOp.HasDefault := True;
  end else
    Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
  SwitchOp.CaseOps.Last.Children.Add( Op );
  Op := nil;
end;

procedure TZc.CleanUp;
begin
  ZFunctions.Free;
end;

procedure TZc.ZError(const S : string);
var
  E : EParseError;
  P : TSymbolRec;
begin
  E := EParseError.Create(S);
  E.Message := S;
  Scanner.GetPosition(P);
  E.Line := P.Line;
  E.Col := P.Col;
  if (E.Line<>0) or (E.Col<>0) then
    E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
  raise E;
end;

function TZc.IsConst : boolean;
begin
  Result := (CurrentInputSymbol=constSym) or
    ((CurrentInputSymbol=privateSym) and (Symbols[2].Id=constSym));
end;

function TZc.GetInitializer : TZcOpFunctionUserDefined;
begin
  if not Self.AllowInitializer then
    ZError('Initializers only allowed in ZLibrary components located in App.OnLoaded');
  if not Assigned(InitializerFunction) then
  begin
    Self.InitializerFunction := TZcOpFunctionUserDefined.Create(nil);
    Self.ZFunctions.Insert(0,Self.InitializerFunction);
  end;
  Result := Self.InitializerFunction;
end;


procedure TZc._ZcFuncRest(Typ : TZcDataType; const Name : string; IsPrivate,IsInline : boolean);

var
  Func : TZcOpFunctionUserDefined;

begin
       
        if SymTab.Contains(Name) then
          ZError('Name already defined: ' + Name);

        if IsPrivate then
          Func := TZcOpFunctionUserDefined.Create(nil)
        else
          Func := TZcOpFunctionUserDefined.Create(GlobalNames);
        Func.Id := Name;
        Func.ReturnType := Typ;
        Func.IsInline := IsInline;
        Self.CurrentFunction := Func;
        SymTab.PushScope;
        try
     
  if InSet(CurrentInputSymbol,0) then
  begin
    _FormalParams;
  end;
  Expect(rparSym);
        
        Func.MangledName := MangleFunc(Name,CurrentFunction.Arguments.Count);
        if SymTab.Contains(Func.MangledName) then
          ZError('Name already defined: ' + Name);
        if IsPrivate then
          SymTab.AddPrevious(Func.MangledName,Func)
        else
          SymTab.AddPrevious(Func.MangledName,Func,2);
        ZFunctions.Add(Func);
      
  Expect(lbraceSym);
  _ZcFuncBody;
  Expect(rbraceSym);
          
          finally
            SymTab.PopScope;
          end;
        
end;

procedure TZc._FormalParams;
begin
  _Par;
  if (CurrentInputSymbol=commaSym) then
  begin
    Get;
    _FormalParams;
  end;
end;

procedure TZc._ZcFuncBody;
              var Op : TZcOp; 
begin
  while InSet(CurrentInputSymbol,1) do
  begin
         Op:=nil; 
    _Statement(Op);
         if Op<>nil then
           CurrentFunction.Statements.Add(Op);
         Op := nil;
      
  end;
end;

procedure TZc._Zc;
      var
        Typ : TZcDataType;
        Name : string;
        IsPrivate,IsInline : boolean;
        Op : TZcOp;
    
begin
  while InSet(CurrentInputSymbol,2) do
  begin
    if (CurrentInputSymbol in [privateSym, constSym]) and ( IsConst ) then
    begin
         IsPrivate := False; 
         if (CurrentInputSymbol=privateSym) then
         begin
           Get;
                     IsPrivate:= True; 
         end;
         _ConstantDeclarationList(IsPrivate);
    end
    else if InSet(CurrentInputSymbol,3) then
    begin
         IsPrivate := False; IsInline := False; 
         if (CurrentInputSymbol=privateSym) then
         begin
           Get;
                     IsPrivate:= True; 
         end;
         if (CurrentInputSymbol=inlineSym) then
         begin
           Get;
                    IsInline:= True; 
         end;
         if (CurrentInputSymbol=voidSym) then
         begin
              Get;
                 Typ.Kind := zctVoid; 
         end
         else if InSet(CurrentInputSymbol,4) then
         begin
              _Type(Typ);
         end
         else SynError(1);
         Expect(identSym);
                                                                Name := LexString; 
         if (CurrentInputSymbol=lparSym) then
         begin
              Get;
              _ZcFuncRest(Typ,Name,IsPrivate,IsInline);
         end
         else if (CurrentInputSymbol in [assgnSym, commaSym, scolonSym]) then
         begin
              _GlobalVarDecl(Typ,Name,IsPrivate);
              Expect(scolonSym);
         end
         else SynError(1);
    end
    else if (CurrentInputSymbol=lbraceSym) then
    begin
         CurrentFunction := GetInitializer; 
         _Block(Op);
         GetInitializer.Statements.Add(Op); CurrentFunction := nil; 
    end
    ;
  end;
end;

procedure TZc._ConstantDeclarationList(IsPrivate : boolean);

var
  Typ : TZcDataType;

begin
  Expect(constSym);
  _Type(Typ);
  _ConstantDeclaration(Typ,IsPrivate);
  while (CurrentInputSymbol=commaSym) do
  begin
    Get;
    _ConstantDeclaration(Typ,IsPrivate);
  end;
  Expect(scolonSym);
end;

procedure TZc._Type(var Typ : TZcDataType);

  var
    A : TDefineArray;
    SizeOp : TZcOp;
    I : integer;

begin
      FillChar(Typ,SizeOf(Typ),0); 
  _SimpleType(Typ);
  while (CurrentInputSymbol=lbrackSym) do
  begin
    Get;
                  
                   A := TDefineArray.Create(nil);
                   GlobalNames.Add(A);
                   A._Type := Typ.Kind;
                   Typ.Kind := zctArray;
                   Typ.TheArray := A;
                
    if InSet(CurrentInputSymbol,5) then
    begin
      _Expr(SizeOp);
                          
            SizeOp := SizeOp.Optimize;
            if SizeOp.Kind<>zcConstLiteral then
              ZError('Array size must be a constant expression');
            A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
                         
    end;
    while (CurrentInputSymbol=commaSym) do
    begin
      Get;
                   if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); 
      if InSet(CurrentInputSymbol,5) then
      begin
        _Expr(SizeOp);
                            
                SizeOp := SizeOp.Optimize;
                if SizeOp.Kind<>zcConstLiteral then
                  ZError('Array size must be a constant expression');
               I := Trunc( (SizeOp as TZcOpLiteral).Value );
               if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
           
      end;
    end;
    Expect(rbrackSym);
  end;
end;

procedure TZc._GlobalVarDecl(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
begin
  _GlobalVarRest(Typ,Name,IsPrivate);
  while (CurrentInputSymbol=commaSym) do
  begin
    Get;
    _GlobalVar(Typ,IsPrivate);
  end;
end;

procedure TZc._Block(var OutOp : TZcOp);
     var
       Op : TZcOp;
  
begin
     Op := nil;
     OutOp := MakeOp(zcBlock);
  
  Expect(lbraceSym);
         SymTab.PushScope;
         try 
  while InSet(CurrentInputSymbol,1) do
  begin
    _Statement(Op);
                       if Assigned(Op) then OutOp.Children.Add(Op); 
  end;
  Expect(rbraceSym);
        
         finally
           SymTab.PopScope;
         end;
      
end;

procedure TZc._Statement(var OutOp : TZcOp);
begin
  if (CurrentInputSymbol=constSym) then
  begin
     OutOp := nil; 
       _ConstantDeclarationList(false);
  end
  else if InSet(CurrentInputSymbol,4) then
  begin
       _LocalVarDecl(OutOp);
       Expect(scolonSym);
  end
  else if InSet(CurrentInputSymbol,6) then
  begin
       _EmbeddedStatement(OutOp);
  end
  else SynError(2);
end;

procedure TZc._Par;
      
var
  Typ : TZcDataType;
  Arg : TZcOpArgumentVar;
  IsPtr : boolean;

begin
      IsPtr := False; 
  if (CurrentInputSymbol=refSym) then
  begin
    Get;
            IsPtr := True; 
  end;
  _Type(Typ);
  Expect(identSym);
       
        Typ.IsPointer := IsPtr;
        if SymTab.ScopeContains(LexString) then
          SynError(201)
        else
        begin
          Arg := TZcOpArgumentVar.Create;
          Arg.Id := LexString;
          Arg.Typ := Typ;
          CurrentFunction.AddArgument(Arg);
          SymTab.Add(Arg.Id,Arg);
        end;
     
end;

procedure TZc._LocalVarDecl(var OutOp : TZcOp);
                                   var Typ : TZcDataType; 
begin
     OutOp := nil; 
  _Type(Typ);
  _LocalVar(Typ,OutOp);
  while (CurrentInputSymbol=commaSym) do
  begin
    Get;
    _LocalVar(Typ,OutOp);
  end;
end;

procedure TZc._LocalVar(Typ : TZcDataType; var OutOp : TZcOp);
                                                  var Loc : TZcOpLocalVar; InitOp : TZcOp; 
begin
  Expect(identSym);
        
        if SymTab.ScopeContains(LexString) then
          ZError('Name already defined: ' + LexString);

        Loc := TZcOpLocalVar.Create(nil);
        Loc.Id := LexString;
        Loc.Typ := Typ;
     
  if (CurrentInputSymbol=assgnSym) then
  begin
    Get;
    _Init(InitOp);
                           Loc.InitExpression:=InitOp; 
  end;
       
        SymTab.Add(Loc.Id,Loc);
        CurrentFunction.AddLocal(Loc);

        if Assigned(Loc.InitExpression) then
        begin
          //Generate tree for initial assignment
          if OutOp=nil then
            OutOp := MakeOp(zcBlock);
          OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
        end;

     
end;

procedure TZc._Init(var OutOp : TZcOp);
begin
  _Expr(OutOp);
end;

procedure TZc._GlobalVarRest(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
 var V : TDefineVariableBase; InitOp : TZcOp; 
begin
       
        if SymTab.ScopeContains(Name) then
          ZError('Name already defined: ' + Name);

        if Typ.Kind=zctArray then
        begin
          TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
          V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
          V._ReferenceClassId := Typ.ReferenceClassId;
          Self.ZApp.GlobalVars.AddComponent(V);
        end
        else
        begin
          V := TDefineVariable.Create(Self.ZApp.GlobalVars);
          V._Type := Typ.Kind;
          V._ReferenceClassId := Typ.ReferenceClassId;
        end;

        V.SetString('Name', AnsiString(Name));
        V.DesignerReset; //Needed to init managed variables
        if IsPrivate then
          SymTab.Add(Name,V)
        else
          SymTab.AddPrevious(Name,V);
     
  if (CurrentInputSymbol=assgnSym) then
  begin
    Get;
    _Init(InitOp);
                          
       GetInitializer.Statements.Add( MakeAssign(atAssign, CheckPrimary( MakeIdentifier(Name) ),InitOp) );
       
  end;
end;

procedure TZc._GlobalVar(Typ : TZcDataType; IsPrivate : boolean);
begin
  Expect(identSym);
  _GlobalVarRest(Typ,LexString,IsPrivate);
end;

procedure TZc._Expr(var OutOp : TZcOp);
                             var Op1,Op2 : TZcOp; Kind : TZcAssignType; 
begin
     Op1 :=nil; Op2 := nil; 
  _Unary(Op1);
  if InSet(CurrentInputSymbol,7) then
  begin
       _OrExpr(Op1,OutOp);
       if (CurrentInputSymbol=_querySym) then
       begin
         Get;
         _Expr(Op1);
         Expect(colonSym);
         _Expr(Op2);
            if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
              SynError(205)
            else
              OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
         
       end;
  end
  else if InSet(CurrentInputSymbol,8) then
  begin
       _AssignOp(Kind);
       _Expr(Op2);
                                   OutOp := MakeAssign(Kind,Op1, Op2); 
  end
  else SynError(3);
end;

procedure TZc._Argument(var OutOp : TZcOp);
begin
     OutOp := nil; 
  _Expr(OutOp);
     if OutOp=nil then ZError('Missing argument'); 
end;

procedure TZc._SimpleType(var Typ : TZcDataType);

  var
    A : TDefineArray;

begin
  if (CurrentInputSymbol=floatSym) then
  begin
       Get;
             Typ.Kind := zctFloat; 
  end
  else if (CurrentInputSymbol=intSym) then
  begin
       Get;
             Typ.Kind := zctInt; 
  end
  else if (CurrentInputSymbol=byteSym) then
  begin
       Get;
              Typ.Kind := zctByte; 
  end
  else if (CurrentInputSymbol=stringSym) then
  begin
       Get;
                Typ.Kind := zctString; 
  end
  else if (CurrentInputSymbol=modelSym) then
  begin
       Get;
               Typ.Kind := zctModel; 
  end
  else if (CurrentInputSymbol=xptrSym) then
  begin
       Get;
              Typ.Kind := zctXptr; 
  end
  else if (CurrentInputSymbol=mat_fourSym) then
  begin
       Get;
             
     A := Prototypes.Mat4Array;
     Typ.Kind := zctMat4;
     Typ.TheArray := A;
    
  end
  else if (CurrentInputSymbol=vec_twoSym) then
  begin
       Get;
             
     A := Prototypes.Vec2Array;
     Typ.Kind := zctVec2;
     Typ.TheArray := A;
  
  end
  else if (CurrentInputSymbol=vec_threeSym) then
  begin
       Get;
             
     A := Prototypes.Vec3Array;
     Typ.Kind := zctVec3;
     Typ.TheArray := A;
  
  end
  else if (CurrentInputSymbol=vec_fourSym) then
  begin
       Get;
             
     A := Prototypes.Vec4Array;
     Typ.Kind := zctVec4;
     Typ.TheArray := A;
  
  end
  else if (CurrentInputSymbol=MaterialSym) then
  begin
       Get;
                  Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; 
  end
  else if (CurrentInputSymbol=SoundSym) then
  begin
       Get;
               Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; 
  end
  else if (CurrentInputSymbol=ShaderSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; 
  end
  else if (CurrentInputSymbol=BitmapSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; 
  end
  else if (CurrentInputSymbol=MeshSym) then
  begin
       Get;
              Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; 
  end
  else if (CurrentInputSymbol=CameraSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; 
  end
  else if (CurrentInputSymbol=FontSym) then
  begin
       Get;
              Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; 
  end
  else if (CurrentInputSymbol=SampleSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; 
  end
  else if (CurrentInputSymbol=FileSym) then
  begin
       Get;
              Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; 
  end
  else if (CurrentInputSymbol=ComponentSym) then
  begin
       Get;
                   Typ.Kind := zctReference; Typ.ReferenceClassId := AnyComponentClassId; 
  end
  else SynError(4);
end;

procedure TZc._ConstantDeclaration(var Typ : TZcDataType; IsPrivate : boolean);

var
  Cns : TDefineConstant;
  Op : TZcOp;
  Lit : TZcOpLiteral;
  CnsName : string;

begin
  Expect(identSym);
         CnsName := LexString; 
  Expect(assgnSym);
  _Expr(Op);
    
   if not (Typ.Kind in [zctByte,zctInt,zctFloat,zctString]) then
     ZError('Only byte, int, float and string constants are allowed');

   Op := Op.Optimize;
   if not (Op is TZcOpLiteral) then
     ZError('Constant expression expected: ' + Op.ToString);

   Lit := Op as TZcOpLiteral;

   if (Lit.Typ.Kind<>Typ.Kind)
     and not ((Typ.Kind=zctByte) and (Lit.Typ.Kind=zctInt))
     and not ((Typ.Kind=zctInt) and (Lit.Typ.Kind=zctFloat))
     then
     ZError('Constant expression is not of the expected type: ' + Op.ToString);

   Cns := TDefineConstant.Create(nil);
   Cns.SetString('Name',AnsiString(CnsName));
   GlobalNames.Add(Cns);

   case Typ.Kind of
     zctByte:
       begin
         Cns._Type := zctByte;
         Cns.ByteValue := Round(Lit.Value);
       end;
     zctInt:
       begin
         Cns._Type := zctInt;
         Cns.IntValue := Round(Lit.Value);
       end;
     zctFloat:
       begin
         Cns._Type := zctFloat;
         Cns.Value := Lit.Value;
       end;
     zctString:
       begin
         Cns._Type := zctString;
         Cns.SetString('StringValue',AnsiString(Lit.StringValue));
       end;
     else
       ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
   end;
   if IsPrivate then
     SymTab.Add(CnsName,Cns)
   else
     SymTab.AddPrevious(CnsName,Cns)
  
end;

procedure TZc._EmbeddedStatement(var OutOp : TZcOp);
     var
       SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
       ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
       WhileCondOp,WhileBodyOp : TZcOp;
       SwitchOp : TZcOpSwitch;
       Loc : TZcOpLocalVar;
  
begin
  if (CurrentInputSymbol=lbraceSym) then
  begin
       _Block(OutOp);
  end
  else if (CurrentInputSymbol=scolonSym) then
  begin
       Get;
           OutOp := MakeOp(zcNop); 
  end
  else if InSet(CurrentInputSymbol,5) then
  begin
       _StatementExpr(OutOp);
       Expect(scolonSym);
  end
  else if (CurrentInputSymbol=ifSym) then
  begin
       Get;
          ElseOp := nil; 
       Expect(lparSym);
       _Expr(IfOp);
       Expect(rparSym);
       _EmbeddedStatement(IfBody);
       if (CurrentInputSymbol=elseSym) then
       begin
         Get;
         _EmbeddedStatement(ElseOp);
       end;
           OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); 
  end
  else if (CurrentInputSymbol=switchSym) then
  begin
       Get;
       Expect(lparSym);
       _Expr(SwitchValueOp);
       Expect(rparSym);
        
         OutOp := MakeOp(zcBlock);

         SwitchOp := TZcOpSwitch.Create(nil);

         if (SwitchValueOp.Ref is TZcOpVariableBase) or (SwitchValueOp.Kind=zcConstLiteral) then
           SwitchOp.ValueOp := SwitchValueOp
         else
         begin
           Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
           SymTab.Add(Loc.Id,Loc);
           CurrentFunction.AddLocal(Loc);
           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
         end;

         OutOp.Children.Add(SwitchOp);
      
       Expect(lbraceSym);
       while (CurrentInputSymbol in [caseSym, defaultSym]) do
       begin
        SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); 
         _SwitchSection(SwitchOp);
       end;
       Expect(rbraceSym);
  end
  else if (CurrentInputSymbol=whileSym) then
  begin
       Get;
        try
         SymTab.PushScope;
         WhileCondOp := nil; WhileBodyOp := nil; 
       Expect(lparSym);
       _Expr(WhileCondOp);
       Expect(rparSym);
       _EmbeddedStatement(WhileBodyOp);
     
         OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
       finally
         SymTab.PopScope;
       end;
   
  end
  else if (CurrentInputSymbol=doSym) then
  begin
       Get;
        try
         SymTab.PushScope;
         WhileCondOp := nil; WhileBodyOp := nil; 
       _EmbeddedStatement(WhileBodyOp);
       Expect(whileSym);
       Expect(lparSym);
       _Expr(WhileCondOp);
       Expect(rparSym);
       Expect(scolonSym);
     
         OutOp := MakeOp(zcDoWhile,[WhileCondOp,WhileBodyOp]);
       finally
         SymTab.PopScope;
       end;
   
  end
  else if (CurrentInputSymbol=forSym) then
  begin
       Get;
       try
         SymTab.PushScope;
         ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; 
       Expect(lparSym);
       if InSet(CurrentInputSymbol,9) then
       begin
         _ForInit(ForInitOp);
       end;
       Expect(scolonSym);
       if InSet(CurrentInputSymbol,5) then
       begin
         _Expr(ForCondOp);
       end;
       Expect(scolonSym);
       if InSet(CurrentInputSymbol,5) then
       begin
         _ForInc(ForIncOp);
       end;
       Expect(rparSym);
       _EmbeddedStatement(ForBodyOp);
     
         OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
       finally
         SymTab.PopScope;
       end;
   
  end
  else if (CurrentInputSymbol=breakSym) then
  begin
       Get;
       Expect(scolonSym);
                     OutOp := MakeOp(zcBreak); 
  end
  else if (CurrentInputSymbol=continueSym) then
  begin
       Get;
       Expect(scolonSym);
                     OutOp := MakeOp(zcContinue); 
  end
  else if (CurrentInputSymbol=returnSym) then
  begin
      Op := nil; 
       Get;
       if InSet(CurrentInputSymbol,5) then
       begin
         _Expr(Op);
       end;
       Expect(scolonSym);
      
        if (Op=nil) then
        begin
          if CurrentFunction.ReturnType.Kind<>zctVoid then
            SynError(202)
          else
            OutOp := MakeOp(zcReturn);
        end else
        begin
          if CurrentFunction.ReturnType.Kind=zctVoid then
            SynError(203)
          else
            OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
        end;
        Inc(CurrentFunction.ReturnCount);
    
  end
  else SynError(5);
end;

procedure TZc._StatementExpr(var OutOp : TZcOp);
                                              var Op1,Op2 : TZcOp; Kind : TZcAssignType; 
begin
     Op1 :=nil; Op2 := nil; 
  _Unary(Op1);
  if InSet(CurrentInputSymbol,8) then
  begin
       _AssignOp(Kind);
       _Expr(Op2);
      
      if Op2<>nil then
        OutOp := MakeAssign(Kind,Op1,Op2);
    
  end
  else if (CurrentInputSymbol in [commaSym, rparSym, scolonSym]) then
  begin
                                   OutOp := Op1; 
  end
  else SynError(6);
end;

procedure TZc._SwitchSection(SwitchOp : TZcOpSwitch);
                                         var Op : TZcOp; 
begin
     Op := nil; 
  _SwitchLabel(Op);
                       AddSwitchLabel(SwitchOp,Op); 
  while (CurrentInputSymbol in [caseSym, defaultSym]) do
  begin
    _SwitchLabel(Op);
                       AddSwitchLabel(SwitchOp,Op); 
  end;
  _Statement(Op);
                      if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); 
  while InSet(CurrentInputSymbol,1) do
  begin
    _Statement(Op);
                      if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); 
  end;
end;

procedure TZc._ForInit(var OutOp : TZcOp);
                                  var Op : TZcOp; 
begin
     Op:=nil; OutOp := MakeOp(zcBlock); 
  if InSet(CurrentInputSymbol,4) then
  begin
       _LocalVarDecl(Op);
                    if Assigned(Op) then OutOp.Children.Add(Op); 
  end
  else if InSet(CurrentInputSymbol,5) then
  begin
     Op:=nil; 
       _StatementExpr(Op);
                                      if Assigned(Op) then OutOp.Children.Add(Op); 
       while (CurrentInputSymbol=commaSym) do
       begin
       Op:=nil; 
         Get;
         _StatementExpr(Op);
                                            if Assigned(Op) then OutOp.Children.Add(Op); 
       end;
  end
  else SynError(7);
end;

procedure TZc._ForInc(var OutOp : TZcOp);
                                  var Op : TZcOp; 
begin
     Op:=nil;
     OutOp := MakeOp(zcBlock);
  
  _StatementExpr(Op);
                     if Assigned(Op) then OutOp.Children.Add(Op); 
  while (CurrentInputSymbol=commaSym) do
  begin
     Op:=nil; 
    Get;
    _StatementExpr(Op);
                                          if Assigned(Op) then OutOp.Children.Add(Op); 
  end;
end;

procedure TZc._Unary(var OutOp : TZcOp);
                                    var LastOp,Tmp : TZcOp; Kind : TZcOpKind; 
begin
           LastOp := nil; Kind := zcNop; 
  while InSet(CurrentInputSymbol,10) do
  begin
    if (CurrentInputSymbol=minusSym) then
    begin
         Get;
               Kind := zcNegate; 
    end
    else if (CurrentInputSymbol=incSym) then
    begin
         Get;
               Kind := zcPreInc; 
    end
    else if (CurrentInputSymbol=decSym) then
    begin
         Get;
               Kind := zcPreDec; 
    end
    else if (CurrentInputSymbol=notSym) then
    begin
         Get;
               Kind := zcNot; 
    end
    else if (CurrentInputSymbol=tildeSym) then
    begin
         Get;
               Kind := zcBinaryNot; 
    end
    ;
      
       if Kind in [zcNot,zcBinaryNot] then
       begin
         Tmp := MakeOp(Kind);
         if LastOp<>nil then
           LastOp.Children.Add(Tmp);
         LastOp := Tmp;
       end else if Assigned(LastOp) then
         ZError('- ,-- and ++ cannot be combined with other unary ops');
    
  end;
  _Primary(Tmp);
      
       if Kind=zcNegate then
         OutOp := MakeBinary(zcMinus, TZcOpLiteral.Create(Tmp.GetDataType.Kind,0), Tmp)
       else if Kind in [zcNop,zcNot,zcBinaryNot] then
       begin
         if LastOp<>nil then
         begin
           LastOp.Children.Add(Tmp);
           OutOp := LastOp;
         end else
           OutOp := Tmp;
       end else
       begin
         OutOp := MakePrePostIncDec(Kind,Tmp);
       end;
    
end;

procedure TZc._AssignOp(var Kind : TZcAssignType);
begin
  if (CurrentInputSymbol=assgnSym) then
  begin
       Get;
             Kind := atAssign; 
  end
  else if (CurrentInputSymbol=_plus_equalSym) then
  begin
       Get;
             Kind := atPlusAssign; 
  end
  else if (CurrentInputSymbol=_minus_equalSym) then
  begin
       Get;
             Kind := atMinusAssign; 
  end
  else if (CurrentInputSymbol=_star_equalSym) then
  begin
       Get;
             Kind := atMulAssign; 
  end
  else if (CurrentInputSymbol=_slash_equalSym) then
  begin
       Get;
             Kind := atDivAssign; 
  end
  else if (CurrentInputSymbol=_bar_equalSym) then
  begin
       Get;
             Kind := atOrAssign; 
  end
  else if (CurrentInputSymbol=_less_less_equalSym) then
  begin
       Get;
              Kind := atShiftLeftAssign; 
  end
  else if (CurrentInputSymbol=_greater_greater_equalSym) then
  begin
       Get;
              Kind := atShiftRightAssign; 
  end
  else if (CurrentInputSymbol=_and_equalSym) then
  begin
       Get;
             Kind := atAndAssign; 
  end
  else SynError(8);
end;

procedure TZc._SwitchLabel(var OutOp : TZcOp);
begin
  if (CurrentInputSymbol=caseSym) then
  begin
       Get;
       _Expr(OutOp);
       Expect(colonSym);
  end
  else if (CurrentInputSymbol=defaultSym) then
  begin
       Get;
       Expect(colonSym);
  end
  else SynError(9);
end;

procedure TZc._OrExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                   var Op,L,R : TZcOp; 
begin
  _AndExpr(InOp,OutOp);
                           L := OutOp; 
  while (CurrentInputSymbol=_bar_barSym) do
  begin
    Get;
    _Unary(Op);
    _AndExpr(Op,R);
         OutOp := MakeOp(zcOr,[L,R]);
         L := OutOp; 
  end;
end;

procedure TZc._AndExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp; 
begin
  _BitOrExpr(InOp,OutOp);
                            L := OutOp; 
  while (CurrentInputSymbol=_and_andSym) do
  begin
    Get;
    _Unary(Op);
    _BitOrExpr(Op,R);
         OutOp := MakeOp(zcAnd,[L,R]);
         L := OutOp; 
  end;
end;

procedure TZc._BitOrExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                      var Op,L,R : TZcOp; 
begin
  _BitXorExpr(InOp,OutOp);
                            L := OutOp; 
  while (CurrentInputSymbol=orSym) do
  begin
    Get;
    _Unary(Op);
    _BitXorExpr(Op,R);
       OutOp := MakeOp(zcBinaryOr,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._BitXorExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                       var Op,L,R : TZcOp; 
begin
  _BitAndExpr(InOp,OutOp);
                            L := OutOp; 
  while (CurrentInputSymbol=xorSym) do
  begin
    Get;
    _Unary(Op);
    _BitAndExpr(Op,R);
       OutOp := MakeOp(zcBinaryXor,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._BitAndExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                       var Op,L,R : TZcOp; 
begin
  _EqlExpr(InOp,OutOp);
                         L := OutOp; 
  while (CurrentInputSymbol=andSym) do
  begin
    Get;
    _Unary(Op);
    _EqlExpr(Op,R);
       OutOp := MakeOp(zcBinaryAnd,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._EqlExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp; Kind : TZcOpKind; 
begin
  _RelExpr(InOp,OutOp);
                         L := OutOp; Kind := zcNop; 
  while (CurrentInputSymbol in [eqSym, neqSym]) do
  begin
    if (CurrentInputSymbol=neqSym) then
    begin
         Get;
               Kind := zcCompNE; 
    end
    else if (CurrentInputSymbol=eqSym) then
    begin
         Get;
               Kind := zcCompEQ; 
    end
    ;
    _Unary(Op);
    _RelExpr(Op,R);
            OutOp := MakeBinary(Kind, L,R);
            L := OutOp;
         
  end;
end;

procedure TZc._RelExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp;  Kind : TZcOpKind; 
begin
  _ShiftExpr(InOp,OutOp);
                           L := OutOp; Kind := zcNop; 
  while InSet(CurrentInputSymbol,11) do
  begin
    if (CurrentInputSymbol=ltSym) then
    begin
         Get;
                   Kind := zcCompLT; 
    end
    else if (CurrentInputSymbol=gtSym) then
    begin
         Get;
                   Kind := zcCompGT; 
    end
    else if (CurrentInputSymbol=lteSym) then
    begin
         Get;
                   Kind := zcCompLE; 
    end
    else if (CurrentInputSymbol=gteSym) then
    begin
         Get;
                   Kind := zcCompGE; 
    end
    ;
    _Unary(Op);
    _ShiftExpr(Op,R);
            OutOp := MakeBinary(Kind, L,R );
            L := OutOp;
         
  end;
end;

procedure TZc._ShiftExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                      var Op,L,R : TZcOp; Kind : TZcOpKind; 
begin
  _AddExpr(InOp,OutOp);
                         L := OutOp; Kind := zcNop; 
  while (CurrentInputSymbol in [lshiftSym, rshiftSym]) do
  begin
    if (CurrentInputSymbol=lshiftSym) then
    begin
         Get;
              Kind := zcBinaryShiftL; 
    end
    else if (CurrentInputSymbol=rshiftSym) then
    begin
         Get;
              Kind := zcBinaryShiftR; 
    end
    ;
    _Unary(Op);
    _AddExpr(Op,R);
       OutOp := MakeOp(Kind,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._AddExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp;  Kind : TZcOpKind;
begin
  _MulExpr(InOp,OutOp);
                           L := OutOp; Kind := zcNop; 
  while (CurrentInputSymbol in [minusSym, plusSym]) do
  begin
    if (CurrentInputSymbol=plusSym) then
    begin
         Get;
                 Kind := zcPlus; 
    end
    else if (CurrentInputSymbol=minusSym) then
    begin
         Get;
                 Kind := zcMinus; 
    end
    ;
    _Unary(Op);
    _MulExpr(Op,R);
            
            if (L=nil) or (R=nil) then
              ZError('Invalid syntax');
            OutOp := MakeBinary(Kind,L,R);
            L := OutOp;
         
  end;
end;

procedure TZc._MulExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Tmp : TZcOp; Kind : TZcOpKind; 
begin
     OutOp := InOp; Kind := zcNop; 
  while (CurrentInputSymbol in [divSym, modSym, timesSym]) do
  begin
    if (CurrentInputSymbol=timesSym) then
    begin
         Get;
                 Kind := zcMul; 
    end
    else if (CurrentInputSymbol=divSym) then
    begin
         Get;
                 Kind := zcDiv; 
    end
    else if (CurrentInputSymbol=modSym) then
    begin
         Get;
                 Kind := zcMod; 
    end
    ;
    _Unary(Tmp);
            OutOp := MakeBinary(Kind,InOp,Tmp);
            InOp := OutOp;
         
  end;
end;

procedure TZc._Primary(var OutOp : TZcOp);
 var Op : TZcOp; S : string; V : double;
     Typ : TZcDataType;

begin
                OutOp := nil; 
  if (CurrentInputSymbol=identSym) then
  begin
       Get;
                OutOp := CheckPrimary( MakeIdentifier(LexString) );  
  end
  else if (CurrentInputSymbol=_atSym) then
  begin
       _InlineComponent(OutOp);
  end
  else if InSet(CurrentInputSymbol,12) then
  begin
       _Literal(Typ);
                    
        if Typ.Kind in [zctString,zctNull] then
          OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
        else
        begin
          try
            S := LexString;
            V := ZcStrToFloat(S);
            OutOp := TZcOpLiteral.Create(Typ.Kind,V)
          except on EConvertError do
            SynError(200);
          end;
        end;
     
  end
  else if (CurrentInputSymbol=lparSym) then
  begin
       Get;
       _Expr(OutOp);
       Expect(rparSym);
  end
  else if (CurrentInputSymbol=reinterpret_underscorecastSym) then
  begin
       _ReinterpretCast(OutOp);
  end
  else SynError(10);
  while InSet(CurrentInputSymbol,13) do
  begin
    if (CurrentInputSymbol=incSym) then
    begin
         Get;
          OutOp := MakePrePostIncDec(zcPostInc,OutOp); 
    end
    else if (CurrentInputSymbol=decSym) then
    begin
         Get;
            OutOp := MakePrePostIncDec(zcPostDec,OutOp); 
    end
    else if (CurrentInputSymbol=dotSym) then
    begin
         Get;
           IsInIdent := True; 
         Expect(identSym);
                                         

      if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
        ZError('Invalid use of "."');

      Op := MakeOp(zcSelect,LexString);
      Op.Children.Add(OutOp);

      OutOp := CheckPrimary(Op);

      IsInIdent := False;

    
    end
    else if (CurrentInputSymbol=lparSym) then
    begin
         Get;
          
           if (OutOp=nil) or (OutOp.Kind<>zcIdentifier) then
             ZError('Unexpected "("');
           OutOp.Kind:=zcFuncCall;
         
         if InSet(CurrentInputSymbol,5) then
         begin
           _Argument(Op);
                         OutOp.Children.Add(Op); 
           while (CurrentInputSymbol=commaSym) do
           begin
             Get;
             _Argument(Op);
                               OutOp.Children.Add(Op); 
           end;
         end;
          
           if not VerifyFunctionCall(OutOp,S,CurrentFunction) then
             ZError(S);
        
         Expect(rparSym);
    end
    else if (CurrentInputSymbol=lbrackSym) then
    begin
         Get;
          
           if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
             ZError('Unexpected "["');
           Op := MakeArrayAccess(OutOp);
           OutOp := Op;
         
         _Expr(Op);
                    OutOp.Children.Add( MakeCompatible(Op,zctInt) ); 
         while (CurrentInputSymbol=commaSym) do
         begin
           Get;
           _Expr(Op);
                           OutOp.Children.Add( MakeCompatible(Op,zctInt) ); 
         end;
         Expect(rbrackSym);
    end
    ;
  end;
end;

procedure TZc._InvokeArgument(var OutOp : TZcOp; Ci : TZComponentInfo);

  var
    Op : TZcOp;
    Prop : TZProperty;

begin
     OutOp := nil; Op := nil; 
  Expect(identSym);
          
    Prop := Ci.GetProperties.GetByName(LexString);
    if Prop=nil then
      ZError(LexString + ' is not a property of ' + Ci.ZClassName);
    if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
      ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
    OutOp := MakeOp(zcIdentifier);
    OutOp.Id := LexString;
  
  Expect(colonSym);
  _Expr(Op);
     if Op=nil then
       ZError('Missing argument');
     Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
     OutOp.Children.Add(Op);
  
end;

procedure TZc._ReinterpretCast(var OutOp : TZcOp);

var
  Op : TZcOp;
  Typ : TZcDataType;

begin
  Expect(reinterpret_underscorecastSym);
  Expect(ltSym);
  _SimpleType(Typ);
  Expect(gtSym);
  Expect(lparSym);
  _Expr(Op);
  Expect(rparSym);
    
     OutOp := TZcOpReinterpretCast.Create(nil);
     OutOp.Children.Add(Op);
     (OutOp as TZcOpReinterpretCast).Typ := Typ;
  
end;

procedure TZc._InlineComponent(var OutOp : TZcOp);
 var Op : TZcOp;
     Ci : TZComponentInfo;

begin
      OutOp := nil;
      IsInInvokeArg := True;
   
  Expect(_atSym);
  Expect(identSym);
               
       Ci := ComponentManager.GetInfoFromName(LexString);
       OutOp := TZcOpInvokeComponent.Create(nil);
       OutOp.Id := LexString;
    
  Expect(lparSym);
  if (CurrentInputSymbol=identSym) then
  begin
    _InvokeArgument(Op,Ci);
                                        OutOp.Children.Add(Op); 
    while (CurrentInputSymbol=commaSym) do
    begin
      Get;
      _InvokeArgument(Op,Ci);
                                        OutOp.Children.Add(Op); 
    end;
  end;
  Expect(rparSym);
           IsInInvokeArg := False; 
end;

procedure TZc._Literal(var Typ : TZcDataType);
begin
  if (CurrentInputSymbol=intConSym) then
  begin
       Get;
            Typ.Kind :=zctInt; 
  end
  else if (CurrentInputSymbol=realConSym) then
  begin
       Get;
             Typ.Kind := zctFloat; 
  end
  else if (CurrentInputSymbol=stringConSym) then
  begin
       Get;
               Typ.Kind := zctString; 
  end
  else if (CurrentInputSymbol=nullSym) then
  begin
       Get;
              Typ.Kind := zctNull; 
  end
  else SynError(11);
end;



function TZc.TokenToString(n: Integer): String;
const TokenStrings: array[0.._NOSYMB] of String = ('EOF'
	,'intCon'	,'realCon'	,'stringCon'	,'ident'	,'"&"'
	,'"="'	,'":"'	,'","'	,'"--"'	,'"/"'
	,'"."'	,'"=="'	,'">"'	,'">="'	,'"++"'
	,'"{"'	,'"["'	,'"("'	,'"<<"'	,'"<"'
	,'"<="'	,'"-"'	,'"%"'	,'"!="'	,'"!"'
	,'"|"'	,'"+"'	,'"}"'	,'"]"'	,'")"'
	,'">>"'	,'";"'	,'"~"'	,'"*"'	,'"^"'
	,'"Material"'	,'"Sound"'	,'"Shader"'	,'"Bitmap"'	,'"Mesh"'
	,'"Camera"'	,'"Font"'	,'"Sample"'	,'"File"'	,'"Component"'
	,'"private"'	,'"inline"'	,'"void"'	,'"ref"'	,'"float"'
	,'"int"'	,'"byte"'	,'"string"'	,'"model"'	,'"xptr"'
	,'"mat4"'	,'"vec2"'	,'"vec3"'	,'"vec4"'	,'"const"'
	,'"if"'	,'"else"'	,'"switch"'	,'"while"'	,'"do"'
	,'"for"'	,'"break"'	,'"continue"'	,'"return"'	,'"+="'
	,'"-="'	,'"*="'	,'"/="'	,'"|="'	,'"<<="'
	,'">>="'	,'"&="'	,'"case"'	,'"default"'	,'"?"'
	,'"||"'	,'"&&"'	,'"reinterpret_cast"'	,'"@"'	,'"null"'
  ,'not');
begin
  if n in [0.._NOSYMB] then
    Result := TokenStrings[n]
  else Result := '?';
end;

function TZc.ErrorMessage(ErrorType, ErrorCode: Integer; const data: string): String;
begin
  case ErrorCode of
	1 : Result := 'invalid Zc';
	2 : Result := 'invalid Statement';
	3 : Result := 'invalid Expr';
	4 : Result := 'invalid SimpleType';
	5 : Result := 'invalid EmbeddedStatement';
	6 : Result := 'invalid StatementExpr';
	7 : Result := 'invalid ForInit';
	8 : Result := 'invalid AssignOp';
	9 : Result := 'invalid SwitchLabel';
	10 : Result := 'invalid Primary';
	11 : Result := 'invalid Literal';

              
    200 : Result := 'Not a floating point value';
    201 : Result := 'Name already defined in this scope';
    202 : Result := 'Return value expected';
    203 : Result := 'Function should not return a value';
    204 : Result := 'Only function definitions are allowed here';
    205 : Result := 'Syntax not supported';

    else Result := inherited ErrorMessage(ErrorType, ErrorCode,data);
  end;
end;

(*

procedure TZc.ProcessPragmas;
begin
  case CurrentInputSymbol of
  end;

end;

*)

function TZc.Execute: Boolean;
begin
  Reinit;
  _Zc;
  Result := Successful;
end;


function TZc.CreateScanner: TBaseScanner;
begin
  Result := TZcScanner.Create(Self);
  if ZcST=nil then
  begin
    ZcST := TStartTable.Create;
    with ZcST do
    begin
	  FillRange(49, 57, 39);  FillRange(65, 90, 18);  States[95] := 18;  FillRange(97, 122, 18);
	  States[48] := 40;  States[46] := 41;  States[34] := 16;  States[38] := 57;  States[61] := 42;
	  States[58] := 19;  States[44] := 20;  States[45] := 58;  States[47] := 59;  States[62] := 60;
	  States[43] := 61;  States[123] := 25;  States[91] := 26;  States[40] := 27;  States[60] := 62;
	  States[37] := 29;  States[33] := 43;  States[124] := 63;  States[125] := 31;  States[93] := 32;
	  States[41] := 33;  States[59] := 34;  States[126] := 35;  States[42] := 64;  States[94] := 36;
	  States[63] := 53;  States[64] := 56;
    end;
    ZcLiterals := CreateLiterals(True,
	['Material','Sound','Shader','Bitmap','Mesh','Camera','Font','Sample','File','Component','private','inline','void'
		,'ref','float','int','byte','string','model','xptr','mat4','vec2','vec3','vec4','const','if','else','switch','while','do'
		,'for','break','continue','return','case','default','reinterpret_cast','null'],
	[-MaterialSym,-SoundSym,-ShaderSym,-BitmapSym,-MeshSym,-CameraSym,-FontSym,-SampleSym,-FileSym,-ComponentSym,privateSym,inlineSym
		,voidSym,refSym,floatSym,intSym,byteSym,stringSym,modelSym,xptrSym,mat_fourSym,vec_twoSym,vec_threeSym,vec_fourSym
		,constSym,ifSym,elseSym,switchSym,whileSym,doSym,forSym,breakSym,continueSym,returnSym,caseSym,defaultSym,reinterpret_underscorecastSym
		,nullSym]
     );
  end;
  with TZcScanner(Result) do
  begin
      
    noSym := _NOSYMB;
    StartState := ZcST;
    Literals := ZcLiterals;
  end;
end;


constructor TZc.Create(AOwner: TComponent);
begin
              
    ZFunctions := TObjectList.Create(False);
    Self.OnError := OnParserError;

  
  inherited;

  if Length(ZcSymSets)=0 then
  InitSymSets(ZcSymSets,[
    	{ 0} MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, refSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 1} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lbraceSym, lparSym, minusSym, notSym, scolonSym, tildeSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, constSym, ifSym, switchSym, whileSym, doSym, forSym, breakSym, continueSym, returnSym, reinterpret_underscorecastSym, _atSym, nullSym, -1,
	{ 2} lbraceSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, privateSym, inlineSym, voidSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, constSym, -1,
	{ 3} MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, privateSym, inlineSym, voidSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 4} MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 5} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lparSym, minusSym, notSym, tildeSym, reinterpret_underscorecastSym, _atSym, nullSym, -1,
	{ 6} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lbraceSym, lparSym, minusSym, notSym, scolonSym, tildeSym, ifSym, switchSym, whileSym, doSym, forSym, breakSym, continueSym, returnSym, reinterpret_underscorecastSym, _atSym, nullSym, -1,
	{ 7} andSym, colonSym, commaSym, divSym, eqSym, gtSym, gteSym, lshiftSym, ltSym, lteSym, minusSym, modSym, neqSym, orSym, plusSym, rbrackSym, rparSym, rshiftSym, scolonSym, timesSym, xorSym, _querySym, _bar_barSym, _and_andSym, -1,
	{ 8} assgnSym, _plus_equalSym, _minus_equalSym, _star_equalSym, _slash_equalSym, _bar_equalSym, _less_less_equalSym, _greater_greater_equalSym, _and_equalSym, -1,
	{ 9} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lparSym, minusSym, notSym, tildeSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, reinterpret_underscorecastSym, _atSym, nullSym, -1,
	{10} decSym, incSym, minusSym, notSym, tildeSym, -1,
	{11} gtSym, gteSym, ltSym, lteSym, -1,
	{12} intConSym, realConSym, stringConSym, nullSym, -1,
	{13} decSym, dotSym, incSym, lbrackSym, lparSym
  ]); 
  SymSets := ZcSymSets;
  
end;

end.
