TARGET  delphi
<|?Ok|>
  <|?not (genScanner or defined(scanner))|>
   <|ERROR "Template var <scanner> must be defined"|>
  <|end not genscanner|>
  
  <|@stdout|>Done 
  <|?HasWarnings|>Compilation ended with warnings in grammar tests.<|END|>
<|else|>Compilation ended with errors in grammar tests.
<|end ok|>

<|?Ok|><|@pas|><|=header|>
{ This unit was generated by DCocoR.  
  Any code in this file that you edit manually will be over-written when the file is regenerated.
}

unit <|!Gramma|>;

interface

uses Classes,CocoAncestor<|?defined(uses)|>,
<|=uses|><|end used|>;

type
<|=types|>

<|?genScanner|>
  T<|!Gramma|>Scanner = class(TCocoRScanner)
  public<|? IgnoreSet|>
    procedure SkipIgnoreSet; override;<|end IgnoreSet|>
    procedure ScanSym(state: Integer; var sym: Integer); override;
    <|? Comments|>function SkipComments(ind: Integer): Boolean; override;<|end|>
  end;
<|end genScanner|>

  T<|!Gramma|> = class(TCocoRGrammar)
  <|?defined(private)|>private <|=private|><|end|>
  protected
<|=protected|>
<|!ParserDeclarations|>
  public
<|=public|>
    (* <|?Pragmas|>procedure ProcessPragmas; override;<|end|> *)
    function  ErrorMessage(ErrorType,ErrorCode: Integer; const data: string): String; override;
    function  TokenToString(n: Integer): String; override;
    <|?genScanner|>function  CreateScanner: TBaseScanner; override;<|END|>
    function Execute: Boolean; override;

    constructor Create(AOwner: TComponent); override;
<|=publicProps|>
  end;

implementation

const

<|!Tokens|>

var <|!Gramma|>SymSets: TSetArray;

<|?genScanner|>
var
  <|!Gramma|>ST: TStartTable = nil;
  <|!Gramma|>Literals: TStringList = nil;

{ T<|!Gramma|>Scanner }

procedure T<|!Gramma|>Scanner.ScanSym(state: Integer; var sym: Integer);
<|?hasCtxMoves|> var apx: TSymbolRec;
begin
 apx.Beg := -1;
<|else|>begin<|end hasCtxMoves|>
 while True do
 begin
  NextCh;
  case state of
<|!ScanSym|>  
    else begin
      if CurrInputCh=#0 then
           sym := _EOFSYMB
      else sym := <|!noSym|>;
      Exit;
    end;
  end;
 end;
end;

<|? IgnoreSet|>
procedure T<|!Gramma|>Scanner.SkipIgnoreSet;
begin
  while (CurrInputCh = ' ') or 
    ( <|!IgnoreSet|> )
  do NextCh;
end;
<|end IgnoreSet|>

<|? Comments|>
function T<|!Gramma|>Scanner.SkipComments(ind: Integer): Boolean;
begin
  Result := True;
  case ind of
<|!Comments|>
    else Result := False;
  end;
end;
<|end|>

<|end genScanner|>

{ T<|!Gramma|> }

<|=implementation|>

<|!ParserImplementation|>

function T<|!Gramma|>.TokenToString(n: Integer): String;
const TokenStrings: array[0..<|!noSym|>] of String = (<|!TokenStrings|>);
begin
  if n in [0..<|!noSym|>] then
    Result := TokenStrings[n]
  else Result := '?';
end;

function T<|!Gramma|>.ErrorMessage(ErrorType, ErrorCode: Integer; const data: string): String;
begin
  case ErrorCode of
<|!Errors|>
<|=semErrors|>
    else Result := inherited ErrorMessage(ErrorType, ErrorCode,data);
  end;
end;

(*
<|?Pragmas|>
procedure T<|!Gramma|>.ProcessPragmas;
begin
<|!Pragmas|>
end;
<|end Pragmas|>
*)

function T<|!Gramma|>.Execute: Boolean;
begin
  Reinit;
  _<|!Gramma|>;
  Result := Successful;
end;

<|?genScanner|>
function T<|!Gramma|>.CreateScanner: TBaseScanner;
begin
  Result := T<|!Gramma|>Scanner.Create(Self);
  if <|!Gramma|>ST=nil then
  begin
    <|!Gramma|>ST := TStartTable.Create;
    with <|!Gramma|>ST do
    begin
<|!InitStartStates|>
    end;
    <|!Gramma|>Literals := CreateLiterals(<|?IGNORECASE|>False<|else|>True<|END|>,
<|!InitLiterals|>
     );
  end;
  with T<|!Gramma|>Scanner(Result) do
  begin
    <|?IGNORECASE|>CaseInsensitive := True;<|END|>  
    noSym := <|!noSym|>;
    StartState := <|!Gramma|>ST;
    Literals := <|!Gramma|>Literals;
  end;
end;
<|end genScanner|>

constructor T<|!Gramma|>.Create(AOwner: TComponent);
begin
<|=precreate|>  
  inherited;
<|?InitSymSets|>
  if Length(<|!Gramma|>SymSets)=0 then
  InitSymSets(<|!Gramma|>SymSets,[
    <|!InitSymSets|>
  ]); 
  SymSets := <|!Gramma|>SymSets;<|END|>
<|=create|>  
end;

end.<|end Ok|>

<|?(not Ok)or HasWarnings|><|@lst|>
Listing
-------
<|!Listing|>
<|END not Ok|>
