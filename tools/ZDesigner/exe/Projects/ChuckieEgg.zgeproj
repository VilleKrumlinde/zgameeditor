<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="ZGameEditor application" ScreenMode="1" Camera="OrthoCamera" FileVersion="2">
  <OnLoaded>
    <ZExternalLibrary Comment="OpenGL 4.0 graphics" ModuleName="opengl32" DefinitionsFile="opengl.txt">
      <BeforeInitExp>
<![CDATA[if(ANDROID) {
  if(App.GLBase==0)
    this.ModuleName="libGLESv1_CM.so";
  else
    this.ModuleName="libGLESv2.so";
}]]>
      </BeforeInitExp>
    </ZExternalLibrary>
    <ZLibrary Comment="Sprites">
      <Source>
<![CDATA[class gltex {
    //Information about where in the texture atlas the sprite is located
    float w,h,x1,x2,y1,y2;
}

gltex gltex_wall;
gltex gltex_ladder;
gltex gltex_egg;
gltex gltex_grain;
gltex gltex_lift;

gltex[4] gltex_player_r;
gltex[4] gltex_player_l;
gltex[4] gltex_player_up;

gltex[10] gltex_duck;
gltex gltex_big_duck_l1;
gltex gltex_big_duck_l2;
gltex gltex_big_duck_r1;
gltex gltex_big_duck_r2;
gltex gltex_cage_open;
gltex gltex_cage_closed;

gltex gltex_score;
gltex gltex_blank;
gltex gltex_player;
gltex gltex_level;
gltex gltex_bonus;
gltex gltex_time;
gltex gltex_hat;
gltex[10] gltex_digit;


const int TEX_SIZE = 128;
byte[TEX_SIZE * TEX_SIZE * 4] tex_buffer;
int tex_handle;
int tex_x;
int tex_y;
int tex_h;


gltex LoadTexture(byte[] ar,byte[] color) {
  //Copy bytes into texture atlas
  gltex tex = new gltex();

    int mask = 0;
    int i;
    int j;
    int stride;

    int sprite_x=ar[0];
    int sprite_y=ar[1];

    if (tex_x + sprite_x > TEX_SIZE) {
        tex_y += tex_h;
        tex_h = 0;
        tex_x = 0;
    }
    if (sprite_y > tex_h)
        tex_h = sprite_y;
    if (tex_y + tex_h > TEX_SIZE)
        trace("error");
    stride = (TEX_SIZE - sprite_x) * 4;
    int dest = (tex_x + tex_y * TEX_SIZE) * 4;
    int src = 2;
    for (j = 0; j < sprite_y; j++) {
        for (i = 0; i < sprite_x; i++) {
            if ((i & 7) == 0)
                mask = ar[src++];
            tex_buffer[dest++]=color[0];
            tex_buffer[dest++]=color[1];
            tex_buffer[dest++]=color[2];
            if (mask & 0x80) {
                tex_buffer[dest++] = 255;
            }
            else {
                tex_buffer[dest++] = 0;
            }
            mask <<= 1;
        }
        dest += stride;
    }
    float texSize=TEX_SIZE;
    tex.x1 = tex_x / texSize;
    tex.x2 = tex.x1 + sprite_x / texSize;
    tex.y1 = tex_y / texSize;
    tex.y2 = tex.y1 + sprite_y / texSize;
    tex.w = sprite_x;
    tex.h = sprite_y;
    tex_x += sprite_x;

  return tex;
}

void LoadTextures() {
  byte[] data;
  byte[] colorGreen = {0,255,0};
  byte[] colorPurple = {160,32,240};
  byte[] colorYellow = {255,255,0};
  byte[] colorBlack = {0,0,0};

  {
    byte[] data = {0x18, 0x30, 0x00,0x38,0x00,0x00,0x44,0x00,0x00,0x44,0x00,0x00,0x44,0x00,0x00,0x38,0x00,0x00,0x10,0x00,0x00,0xfe,0x00,0x03,0x7d,0x80,0x0c,0xd6,0x60,0x11,0x55,0x10,0x22,0x54,0x88,0x24,0x92,0x48,0x44,0x92,0x44,0x48,0x92,0x24,0x88,0x92,0x22,0x89,0x11,0x22,0xd1,0x11,0x16,0xb1,0x11,0x1a,0x99,0x11,0x32,0x97,0x11,0xd2,0x91,0xff,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0xd1,0x11,0x16,0xb1,0x11,0x1a,0x99,0x11,0x32,0x97,0x11,0xd2,0x91,0xff,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0xd1,0x11,0x12,0x51,0x11,0x14,0x31,0x11,0x18,0x19,0x11,0x30,0x07,0x11,0xc0,0x00,0xfe,0x00};
    gltex_cage_open = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {0x18, 0x30, 0x00,0x38,0x00,0x00,0x44,0x00,0x00,0x44,0x00,0x00,0x44,0x00,0x00,0x38,0x00,0x00,0x10,0x00,0x00,0xfe,0x00,0x03,0x7d,0x80,0x0c,0xd6,0x60,0x11,0x55,0x10,0x22,0x54,0x88,0x24,0x92,0x48,0x44,0x92,0x44,0x48,0x92,0x24,0x88,0x92,0x22,0x89,0x11,0x22,0xd1,0x10,0x16,0xb1,0x10,0x0a,0x99,0x00,0x02,0x97,0x00,0x02,0x91,0xe0,0x02,0x91,0x00,0x02,0x91,0x10,0x02,0x91,0x10,0x12,0x91,0x10,0x12,0x91,0x10,0x12,0x90,0x00,0x12,0x90,0x00,0x12,0x90,0x00,0x12,0xd0,0x00,0x16,0xb0,0x00,0x1a,0x90,0x00,0x32,0x90,0x00,0x12,0x90,0x00,0x12,0x90,0x00,0x12,0x90,0x00,0x12,0x90,0x00,0x12,0x90,0x00,0x12,0x91,0x00,0x12,0x91,0x01,0x12,0x91,0x11,0x12,0x91,0x11,0x12,0xd1,0x11,0x12,0x51,0x11,0x14,0x31,0x11,0x18,0x19,0x11,0x30,0x07,0x11,0xc0,0x00,0xfe,0x00};
    gltex_cage_closed = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {0x10, 0x18, 0x0e,0x00,0x1f,0x00,0x17,0x80,0xf7,0x80,0xff,0x80,0x1f,0x80,0x0f,0x00,0x07,0x00,0x06,0x00,0x0e,0x70,0x0e,0xf8,0x1f,0xfc,0x1f,0xfe,0x1e,0xff,0x1d,0xff,0x3d,0xfd,0x3d,0xfd,0x3d,0xfb,0x3e,0xf6,0x3f,0x6e,0x1f,0x9c,0x1f,0xf8,0x0f,0xf0,0x07,0xc0};
    gltex_big_duck_l1 = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {0x10, 0x18, 0x0e,0x00,0x9f,0x00,0x57,0x80,0x37,0x80,0x3f,0x80,0x5f,0x80,0x8f,0x00,0x07,0x00,0x06,0x00,0x0e,0x70,0x0e,0xf8,0x1f,0xfc,0x1f,0x8e,0x1e,0x77,0x1d,0xfb,0x3f,0xfd,0x3f,0xff,0x3f,0xff,0x3f,0xfe,0x3f,0xfe,0x1f,0xfc,0x1f,0xf8,0x0f,0xf0,0x07,0xc0};
    gltex_big_duck_l2 = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {0x10, 0x18,0x00,0x70,0x00,0xf8,0x01,0xe8,0x01,0xef,0x01,0xff,0x01,0xf8,0x00,0xf0,0x00,0xe0,0x00,0x60,0x0e,0x70,0x1f,0x70,0x3f,0xf8,0x7f,0xf8,0xff,0x78,0xff,0xb8,0xbf,0xbc,0xbf,0xbc,0xdf,0xbc,0x6f,0x7c,0x76,0xfc,0x39,0xf8,0x1f,0xf8,0x0f,0xf0,0x03,0xe0};
    gltex_big_duck_r1 = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {0x10, 0x18, 0x00,0x70,0x00,0xf9,0x01,0xea,0x01,0xec,0x01,0xfc,0x01,0xfa,0x00,0xf1,0x00,0xe0,0x00,0x60,0x0e,0x70,0x1f,0x70,0x3f,0xf8,0x71,0xf8,0xee,0x78,0xdf,0xb8,0xbf,0xfc,0xff,0xfc,0xff,0xfc,0x7f,0xfc,0x7f,0xfc,0x3f,0xf8,0x1f,0xf8,0x0f,0xf0,0x03,0xe0};
    gltex_big_duck_r2 = LoadTexture(data,colorYellow);
  }


  {
    byte[] data = {8,8,251,0,191,0,239,0,0,0};
    gltex_wall = LoadTexture(data,colorGreen);
  }

  {
    byte[] data = {8,8,66,66,66,66,126,66,66,66};
    gltex_ladder = LoadTexture(data,colorPurple);
  }

  {
    byte[] data = {8,8,0,56,108,94,126,124,56,0};
    gltex_egg = LoadTexture(data,colorYellow);
  }

  {
    byte[] data = {8,8,0,0,0,8,20,42,85,0};
    gltex_grain = LoadTexture(data,colorPurple);
  }

  {
    byte[] data = {16,4,31,248,31,248,27,216,17,136};
    gltex_lift = LoadTexture(data,colorPurple);
  }

  {
    byte[] data = {8, 0x10,0x18,0x3c,0xff,0x3c,0x3c,0x18,0x18,0xbd, 0xff,0x7e,0x7e,0x7e,0x3c,0x24,0x24,0x66 };
    gltex_player_up[0] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {8, 0x10,0x18,0x3c,0xff,0x3c,0x3d,0x19,0x19,0x3d,0xff,0xfe,0xfe,0xfe,0xbc,0x3e,0x20,0x20};
    gltex_player_up[1] = LoadTexture(data,colorYellow);
  }
  gltex_player_up[2] = gltex_player_up[0];
  {
    byte[] data = {8, 0x10,0x20,0x60,0x18,0x3c,0xff,0x3c,0xbc,0x98,0x98,0xbc,0xff,0x7f,0x7f,0x7f,0x3d,0x7c};
    gltex_player_up[3] = LoadTexture(data,colorYellow);
  }

  {
    byte[] data = {8,16,24,60,255,52,60,16,24,60,110,110,110,110,60,24,16,24};
    gltex_player_r[0] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {8,16,24,60,255,52,60,16,24,60,110,110,118,118,60,56,74,36};
    gltex_player_r[1] = LoadTexture(data,colorYellow);
  }
  gltex_player_r[2] = gltex_player_r[0];
  {
    byte[] data = {8,16,24,60,255,52,60,16,24,60,110,110,94,94,60,56,74,36};
    gltex_player_r[3] = LoadTexture(data,colorYellow);
  }

  {
    byte[] data = {8,16,24,60,255,44,60,8,24,60,118,118,118,118,60,24,8,24};
    gltex_player_l[0] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {8,16,24,60,255,44,60,8,24,60,118,118,110,110,60,28,82,36};
    gltex_player_l[1] = LoadTexture(data,colorYellow);
  }
  gltex_player_l[2] = gltex_player_l[0];
  {
    byte[] data = {8,16,24,60,255,44,60,8,24,60,118,118,122,122,60,28,82,36};
    gltex_player_l[3] = LoadTexture(data,colorYellow);
  }

  {
    byte[] data = {8,20,12,27,28,8,8,4,4,2,50,123,127,127,127,62,24,16,16,16,16,24};
    gltex_duck[0] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {8,20,13,26,29,8,8,4,4,2,50,123,127,127,127,62,24,40,40,68,69,34};
    gltex_duck[1] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {8,20,48,216,56,16,16,32,32,64,76,222,254,254,254,124,24,8,8,8,8,24};
    gltex_duck[2] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = {8,20,176,88,184,16,16,32,32,64,76,222,254,254,254,124,24,20,20,34,162,68};
    gltex_duck[3] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = { 0x08, 0x14, 0x18,0x3c,0x3c,0x3c,0x18,0x18,0x18,0x3c,0x7e,0x7e,0x7e,0x7e,0x7e,0x3c,0x3c,0x24,0x24,0x26,0x20,0x60};
    gltex_duck[4] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = { 0x08, 0x16, 0x18,0x3c,0x3c,0x3c,0x18,0x18,0x18,0x3c,0x7e,0x7e,0x7e,0x7e,0x7e,0x3c,0x3c,0x24,0x24,0x64,0x04,0x04,0x04,0x06};
    gltex_duck[5] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = { 0x10, 0x14, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x30,0x28,0x78,0x78,0x7c,0xc4,0x7f,0xc2,0x7f,0x80,0x3f,0x00,0x3f,0x00,0x1f,0x00,0x16,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x18,0x00};
    gltex_duck[6] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = { 0x10, 0x14, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x78,0x00,0x7c,0x00,0x7e,0x00,0x7f,0xf8,0x3f,0xf4,0x3f,0x14,0x1f,0x08,0x16,0x08,0x10,0x08,0x10,0x00,0x10,0x00,0x18,0x00};
    gltex_duck[7] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = { 0x10, 0x14, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x00,0x14,0x0c,0x1e,0x1e,0x23,0x3e,0x43,0xfe,0x01,0xfe,0x00,0xfc,0x00,0xfc,0x00,0xf8,0x00,0x68,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x18};
    gltex_duck[8] = LoadTexture(data,colorYellow);
  }
  {
    byte[] data = { 0x10, 0x14, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x00,0x1e,0x00,0x3e,0x00,0x7e,0x1f,0xfe,0x2f,0xfc,0x28,0xfc,0x10,0xf8,0x10,0x68,0x10,0x08,0x00,0x08,0x00,0x08,0x00,0x18};
    gltex_duck[9] = LoadTexture(data,colorYellow);
  }

  { byte[] data = { 0x08, 0x07, 0x60,0x90,0x90,0x90,0x90,0x90,0x60 }; gltex_digit[0]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x20,0x60,0x20,0x20,0x20,0x20,0x70 }; gltex_digit[1]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x60,0x90,0x10,0x20,0x40,0x80,0xf0 }; gltex_digit[2]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x60,0x90,0x10,0x20,0x10,0x90,0x60 }; gltex_digit[3]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x80,0x80,0xa0,0xa0,0xf0,0x20,0x20 }; gltex_digit[4]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0xf0,0x80,0xe0,0x10,0x10,0x90,0x60 }; gltex_digit[5]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x60,0x90,0x80,0xe0,0x90,0x90,0x60 }; gltex_digit[6]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0xf0,0x10,0x10,0x20,0x20,0x40,0x40 }; gltex_digit[7]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x60,0x90,0x90,0x60,0x90,0x90,0x60 }; gltex_digit[8]=LoadTexture(data,colorBlack); }
  { byte[] data = { 0x08, 0x07, 0x60,0x90,0x90,0x70,0x10,0x90,0x60 }; gltex_digit[9]=LoadTexture(data,colorBlack); }


  {
    byte[] data = { 0x18, 0x09,0xff,0xff,0xf8,0x88,0x89,0x88,0xbb,0xaa,0xb8,0xbb,0xaa,0xb8,0x8b,0xa9,0x98,0xeb,0xaa,0xb8,0xeb,0xaa,0xb8,0x88,0x8a,0x88,0xff,0xff,0xf8 };
    gltex_score = LoadTexture(data,colorPurple);
  }
  {
    byte[] data = { 0x20, 0x09, 0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe };
    gltex_blank = LoadTexture(data,colorPurple);
  }
  {
    byte[] data = { 0x20, 0x09, 0xff,0xff,0xff,0xff,0x9b,0xda,0x89,0xff,0xab,0xaa,0xba,0xff,0xab,0xaa,0xba,0xff,0x9b,0x8d,0x99,0xff,0xbb,0xad,0xba,0xff,0xbb,0xad,0xba,0xff,0xb8,0xad,0x8a,0xff,0xff,0xff,0xff,0xff };
    gltex_player = LoadTexture(data,colorPurple);
  }
  {
    byte[] data = { 0x28, 0x09, 0xff,0xff,0xff,0xff,0xfc,0xb8,0xa8,0xbf,0xff,0xfc,0xbb,0xab,0xbf,0xff,0xfc,0xbb,0xab,0xbf,0xff,0xfc,0xb9,0xa9,0xbf,0xff,0xfc,0xbb,0xab,0xbf,0xff,0xfc,0xbb,0xdb,0xbf,0xff,0xfc,0x88,0xd8,0x8f,0xff,0xfc,0xff,0xff,0xff,0xff,0xfc };
    gltex_level = LoadTexture(data,colorPurple);
  }
  {
    byte[] data = { 0x30, 0x09, 0xff,0xff,0xff,0xff,0xff,0xf0,0x98,0xb5,0x47,0xff,0xff,0xf0,0xaa,0x95,0x5f,0xff,0xff,0xf0,0xaa,0x95,0x5f,0xff,0xff,0xf0,0x9a,0xa5,0x47,0xff,0xff,0xf0,0xaa,0xa5,0x77,0xff,0xff,0xf0,0xaa,0xb5,0x77,0xff,0xff,0xf0,0x98,0xb4,0x47,0xff,0xff,0xf0,0xff,0xff,0xff,0xff,0xff,0xf0 };
    gltex_bonus = LoadTexture(data,colorPurple);
  }
  {
    byte[] data = { 0x28, 0x09, 0xff,0xff,0xff,0xff,0xc0,0x8a,0x48,0xff,0xff,0xc0,0xda,0x4b,0xff,0xff,0xc0,0xda,0xab,0xff,0xff,0xc0,0xda,0xa9,0xff,0xff,0xc0,0xda,0xab,0xff,0xff,0xc0,0xda,0xeb,0xff,0xff,0xc0,0xda,0xe8,0xff,0xff,0xc0,0xff,0xff,0xff,0xff,0xc0};
    gltex_time = LoadTexture(data,colorPurple);
  }
  {
    byte[] data = { 0x08, 0x03, 0x40,0xe0,0x00};
    gltex_hat = LoadTexture(data,colorYellow);
  }

    glGenTextures(1, tex_handle);
    glBindTexture(GL_TEXTURE_2D, tex_handle);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
        TEX_SIZE, TEX_SIZE, 0,
        GL_RGBA, GL_UNSIGNED_BYTE, tex_buffer);
}

void RenderSprite(gltex t, float x, float y)
{
    float w = t.w;
    float h = t.h;
    //glBindTexture(GL_TEXTURE_2D, t->handle);
    glBegin(GL_QUADS);
    glTexCoord2f(t.x1, t.y1);
    glVertex2f(x, y);
    glTexCoord2f(t.x1, t.y2);
    glVertex2f(x, y - h);
    glTexCoord2f(t.x2, t.y2);
    glVertex2f(x + w, y - h);
    glTexCoord2f(t.x2, t.y1);
    glVertex2f(x + w, y);
    glEnd();
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="Levels" HasInitializer="1">
      <Source>
<![CDATA[class TLevels {
  private byte[] level1 = { /* 0cd0 */
/*0x0cd0*/0x0d,0x04,0x00,0x0a,0x02,0x01,0x00,0x13,0x06,0x01,0x12,0x0b,0x02,0x08,0x0b,0x0e,
/*0x0ce0*/0x12,0x0c,0x09,0x0a,0x0d,0x0b,0x0c,0x0e,0x0d,0x0e,0x0f,0x0f,0x10,0x10,0x03,0x07,
/*0x0cf0*/0x11,0x09,0x0b,0x15,0x05,0x09,0x15,0x0b,0x10,0x15,0x12,0x13,0x03,0x07,0x0d,0x07,
/*0x0d00*/0x02,0x17,0x0b,0x02,0x08,0x10,0x02,0x08,0x04,0x02,0x01,0x07,0x0d,0x07,0x12,0x07,
/*0x0d10*/0x02,0x0c,0x0a,0x0d,0x11,0x0c,0x04,0x11,0x0a,0x12,0x06,0x16,0x0d,0x16,0x13,0x16,
/*0x0d20*/0x02,0x02,0x0d,0x02,0x05,0x07,0x0e,0x07,0x05,0x0c,0x0f,0x0c,0x10,0x10,0x0b,0x12,
/*0x0d30*/0x09,0x16,0x0e,0x16,0x05,0x11,0x08,0x16,0x04,0x0c,0x06,0x07,0x0c,0x02
  };

  private byte[] level2 = { /* 0d3e */
0x0d,0x08,
/*0x0d40*/0x00,0x07,0x03,0x01,0x00,0x03,0x01,0x05,0x13,0x06,0x00,0x06,0x06,0x08,0x0a,0x06,
/*0x0d50*/0x0c,0x0e,0x06,0x10,0x13,0x0b,0x00,0x03,0x0b,0x05,0x0e,0x0b,0x10,0x13,0x10,0x00,
/*0x0d60*/0x0a,0x10,0x0c,0x13,0x15,0x04,0x0a,0x15,0x0c,0x13,0x02,0x02,0x12,0x04,0x11,0x17,
/*0x0d70*/0x06,0x07,0x12,0x09,0x02,0x08,0x09,0x0c,0x17,0x0d,0x0c,0x12,0x11,0x02,0x0d,0x11,
/*0x0d80*/0x11,0x17,0x05,0x02,0x0c,0x02,0x00,0x07,0x04,0x07,0x0d,0x07,0x00,0x0c,0x07,0x0c,
/*0x0d90*/0x13,0x0c,0x07,0x11,0x07,0x16,0x0f,0x16,0x13,0x16,0x00,0x02,0x03,0x02,0x0f,0x02,
/*0x0da0*/0x10,0x07,0x00,0x11,0x0a,0x11,0x0c,0x16,0x06,0x16,0x01,0x02,0x12,0x0c,0x0b,0x0c,
/*0x0db0*/0x0d,0x16
  };

  private byte[] level3 =  { /* 0db2 */
0x18,0x07,0x01,0x0a,0x03,0x01,0x00,0x02,0x02,0x03,0x04,0x01,0x07,0x09,
/*0x0dc0*/0x01,0x0b,0x13,0x05,0x0f,0x12,0x0a,0x00,0x04,0x0f,0x00,0x03,0x13,0x03,0x04,0x06,
/*0x0dd0*/0x07,0x0a,0x06,0x0c,0x0c,0x07,0x0e,0x0e,0x08,0x0f,0x0f,0x09,0x11,0x11,0x0a,0x12,
/*0x0de0*/0x13,0x0c,0x0c,0x0d,0x0c,0x0f,0x0f,0x0f,0x12,0x13,0x10,0x11,0x11,0x11,0x0f,0x0f,
/*0x0df0*/0x12,0x0c,0x0d,0x13,0x07,0x0b,0x15,0x0d,0x0f,0x14,0x10,0x10,0x14,0x12,0x13,0x01,
/*0x0e00*/0x02,0x0c,0x03,0x0b,0x15,0x08,0x07,0x15,0x0a,0x07,0x15,0x0d,0x13,0x17,0x12,0x02,
/*0x0e10*/0x07,0x13,0x0b,0x11,0x05,0x04,0x03,0x0f,0x02,0x10,0x06,0x04,0x0b,0x04,0x14,0x09,
/*0x0e20*/0x07,0x0f,0x09,0x0f,0x0d,0x01,0x10,0x11,0x11,0x13,0x12,0x13,0x15,0x02,0x02,0x02,
/*0x0e30*/0x0b,0x07,0x07,0x07,0x14,0x00,0x10,0x0d,0x02,0x0c,0x13,0x0f,0x12,0x0d,0x0d,0x12,
/*0x0e40*/0x15,0x02,0x10,0x09,0x14,0x11,0x06,0x00,0x02,0x08,0x07
};

  private byte[] level4 =  { /* 0e4b */
0x1a,0x05,0x01,0x06,0x04,
/*0x0e50*/0x01,0x00,0x04,0x01,0x06,0x0a,0x01,0x0d,0x13,0x06,0x00,0x04,0x06,0x07,0x0a,0x06,
/*0x0e60*/0x0d,0x11,0x05,0x13,0x13,0x0c,0x00,0x01,0x0d,0x03,0x03,0x0e,0x05,0x05,0x0f,0x07,
/*0x0e70*/0x08,0x0b,0x07,0x08,0x0b,0x0d,0x10,0x0a,0x12,0x13,0x10,0x08,0x0a,0x11,0x00,0x00,
/*0x0e80*/0x12,0x02,0x02,0x13,0x03,0x03,0x14,0x04,0x04,0x15,0x05,0x05,0x15,0x07,0x0a,0x10,
/*0x0e90*/0x0d,0x0e,0x10,0x10,0x10,0x10,0x12,0x13,0x15,0x0d,0x0f,0x15,0x11,0x13,0x03,0x02,
/*0x0ea0*/0x08,0x08,0x02,0x17,0x0e,0x0c,0x17,0x0f,0x02,0x08,0x13,0x10,0x17,0x0b,0x00,0x02,
/*0x0eb0*/0x00,0x0d,0x00,0x12,0x07,0x07,0x09,0x11,0x0d,0x02,0x10,0x07,0x0d,0x0c,0x13,0x0b,
/*0x0ec0*/0x11,0x10,0x10,0x15,0x10,0x18,0x00,0x07,0x0a,0x02,0x12,0x02,0x05,0x0f,0x09,0x16,
/*0x0ed0*/0x0d,0x16,0x0a,0x16,0x11,0x16,0x11,0x02,0x04,0x02,0x0a,0x07
};

  private byte[] level5 = { /* 0edc */
0x11,0x09,0x01,0x0d,
/*0x0ee0*/0x04,0x01,0x00,0x01,0x01,0x03,0x0b,0x01,0x0d,0x0f,0x01,0x12,0x13,0x06,0x00,0x05,
/*0x0ef0*/0x06,0x09,0x0c,0x06,0x0e,0x0f,0x0b,0x00,0x05,0x0b,0x0a,0x0f,0x0b,0x13,0x13,0x10,
/*0x0f00*/0x00,0x05,0x15,0x03,0x07,0x14,0x09,0x09,0x13,0x0b,0x0d,0x12,0x0e,0x0e,0x16,0x0c,
/*0x0f10*/0x0f,0x15,0x12,0x13,0x03,0x02,0x08,0x02,0x0c,0x12,0x04,0x0c,0x17,0x07,0x02,0x07,
/*0x0f20*/0x07,0x0a,0x11,0x0a,0x02,0x08,0x0c,0x07,0x0d,0x0c,0x14,0x18,0x0e,0x02,0x08,0x10,
/*0x0f30*/0x00,0x02,0x00,0x07,0x00,0x0c,0x00,0x11,0x05,0x07,0x05,0x16,0x09,0x0b,0x0d,0x06,
/*0x0f40*/0x0b,0x14,0x0d,0x17,0x13,0x0c,0x13,0x16,0x04,0x02,0x05,0x02,0x06,0x02,0x0d,0x02,
/*0x0f50*/0x0f,0x02,0x12,0x02,0x0a,0x0c,0x0f,0x0c,0x03,0x16,0x06,0x16,0x07,0x16,0x0f,0x17,
/*0x0f60*/0x12,0x16,0x01,0x07,0x03,0x0c,0x01,0x11,0x0e,0x0c,0x0f,0x07
};

  private byte[] level6 = { /* 0f6c */
0x10,0x06,0x01,0x09,
/*0x0f70*/0x04,0x01,0x00,0x02,0x01,0x06,0x08,0x01,0x0b,0x0e,0x06,0x00,0x01,0x06,0x03,0x05,
/*0x0f80*/0x06,0x0c,0x0e,0x0b,0x02,0x07,0x0b,0x0c,0x11,0x0a,0x11,0x13,0x10,0x00,0x05,0x10,
/*0x0f90*/0x10,0x13,0x15,0x06,0x06,0x15,0x08,0x08,0x14,0x0c,0x11,0x16,0x11,0x13,0x02,0x11,
/*0x0fa0*/0x11,0x00,0x02,0x08,0x04,0x04,0x12,0x0e,0x07,0x0d,0x0e,0x13,0x17,0x11,0x02,0x0d,
/*0x0fb0*/0x11,0x10,0x18,0x09,0x02,0x02,0x10,0x02,0x05,0x07,0x0c,0x07,0x0c,0x0c,0x10,0x0c,
/*0x0fc0*/0x07,0x11,0x03,0x15,0x06,0x16,0x0c,0x15,0x13,0x11,0x13,0x17,0x0b,0x02,0x0c,0x02,
/*0x0fd0*/0x0d,0x02,0x0e,0x02,0x00,0x11,0x02,0x11,0x03,0x11,0x07,0x0c,0x13,0x0b,0x01,0x11,
/*0x0fe0*/0x01,0x02,0x12,0x11,0x0d,0x07,0x12,0x0b,
};

  private byte[] level7 = { /* 0fe8 */
0x17,0x07,0x01,0x04,0x03,0x15,0x0b,0x10,
/*0x0ff0*/0x10,0x00,0x04,0x10,0x06,0x07,0x0b,0x00,0x02,0x06,0x01,0x03,0x04,0x00,0x01,0x01,
/*0x1000*/0x03,0x04,0x02,0x05,0x06,0x01,0x07,0x08,0x02,0x09,0x09,0x03,0x09,0x09,0x03,0x0c,
/*0x1010*/0x0c,0x08,0x05,0x08,0x09,0x05,0x05,0x0a,0x05,0x05,0x0b,0x05,0x05,0x0c,0x05,0x05,
/*0x1020*/0x0b,0x08,0x08,0x0c,0x08,0x08,0x0f,0x0c,0x0f,0x0b,0x0a,0x0b,0x09,0x0e,0x10,0x02,
/*0x1030*/0x0f,0x10,0x01,0x02,0x12,0x03,0x02,0x08,0x05,0x14,0x18,0x07,0x14,0x18,0x09,0x14,
/*0x1040*/0x18,0x0d,0x10,0x17,0x0f,0x0a,0x11,0x12,0x06,0x17,0x08,0x17,0x0a,0x17,0x0f,0x16,
/*0x1050*/0x07,0x11,0x02,0x03,0x07,0x09,0x0b,0x0c,0x10,0x0f,0x10,0x0a,0x0c,0x04,0x11,0x02,
/*0x1060*/0x02,0x07,0x03,0x11,0x08,0x09,0x0c,0x16,0x0d,0x16,0x01,0x11,0x0e,0x0a,0x00,0x05,
/*0x1070*/0x02,0x0c,
};

  private byte[] level8 = { /* 1072 */
0x0f,0x06,0x00,0x10,0x03,0x01,0x00,0x13,0x06,0x02,0x04,0x06,0x07,0x0d,
/*0x1080*/0x06,0x10,0x12,0x0b,0x02,0x05,0x0b,0x08,0x0c,0x0b,0x0f,0x12,0x10,0x03,0x06,0x10,
/*0x1090*/0x09,0x0b,0x10,0x0e,0x11,0x15,0x03,0x03,0x15,0x06,0x06,0x15,0x08,0x0c,0x15,0x0e,
/*0x10a0*/0x0e,0x15,0x11,0x11,0x03,0x02,0x08,0x11,0x02,0x08,0x0a,0x07,0x0d,0x04,0x0c,0x12,
/*0x10b0*/0x10,0x0c,0x12,0x0a,0x11,0x17,0x05,0x06,0x0f,0x06,0x06,0x0b,0x0e,0x0b,0x08,0x10,
/*0x10c0*/0x0c,0x10,0x05,0x15,0x0f,0x15,0x07,0x15,0x0d,0x15,0x03,0x18,0x11,0x18,0x01,0x02,
/*0x10d0*/0x02,0x02,0x04,0x02,0x05,0x02,0x06,0x02,0x08,0x02,0x09,0x02,0x0a,0x02,0x0b,0x02,
/*0x10e0*/0x0c,0x02,0x0d,0x02,0x0e,0x02,0x0f,0x02,0x10,0x02,0x12,0x02,0x13,0x02,0x11,0x02,
/*0x10f0*/0x0a,0x0c,0x0a,0x16,0x03,0x11,0x11,0x11,0x55,0x42,0x28,0x34,0x29,0x3a,0x20,0x45,
};

  void getLevel(int i,ref byte[] data) {
    switch(i) {
      case 0 : data=level1; break;
      case 1 : data=level2; break;
      case 2 : data=level3; break;
      case 3 : data=level4; break;
      case 4 : data=level5; break;
      case 5 : data=level6; break;
      case 6 : data=level7; break;
      case 7 : data=level8; break;
    }
  }
}

TLevels levels = new TLevels();]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="Main" HasInitializer="1">
      <Source>
<![CDATA[/* Chuckie Egg.  Based on the original by A & F Software
   Written by Paul Brook
   Released under the GNU GPL v3.
   https://github.com/pbrook/Chuckie-Egg

   Adapted for ZGE script by Ville 2021.
*/

const int cNUM_PLAYERS=1;

const int cPLAYER_WALK = 0;
const int cPLAYER_CLIMB = 1;
const int cPLAYER_JUMP = 2;
const int cPLAYER_FALL = 3;
const int cPLAYER_LIFT = 4;

const int TILE_WALL     = 1;
const int TILE_LADDER   = 2;
const int TILE_EGG      = 4;
const int TILE_GRAIN    = 8;

const int DUCK_BORED = 0;
const int DUCK_STEP = 1;
const int DUCK_EAT1 = 2;
const int DUCK_EAT2 = 3;
const int DUCK_EAT3 = 4;
const int DUCK_EAT4 = 5;

const int BUTTON_RIGHT  = 1;
const int BUTTON_LEFT   = 2;
const int BUTTON_DOWN   = 4;
const int BUTTON_UP     = 8;
const int BUTTON_JUMP   = 0x10;

const int DIR_L     = 1;
const int DIR_R     = 2;
const int DIR_UP    = 4;
const int DIR_DOWN  = 8;
const int DIR_HORIZ = (DIR_R | DIR_L);

int skip_frame;
int cheat;
int is_dead;
int zero_bonus;
int extra_life;
int num_players;
int active_players;
int current_player;
int current_level;
int eggs_left;
int bonus_hold;
int have_lift;
int lift_x;
int[2] lift_y;
int current_lift;
int have_big_duck;
int duck_timer;
int big_duck_frame;
int big_duck_x;
int big_duck_dx;
int big_duck_y;
int big_duck_dy;
int big_duck_dir;
int num_ducks;
int current_duck;
int duck_speed;
byte[4] bonus;
byte[3] timer_ticks;
byte[4] level;
byte[20*25] levelmap;
int player_mode = cPLAYER_WALK;
int player_fall;
int player_slide;
int player_face;
int player_x;
int player_y;
int player_tilex;
int player_tiley;
int player_partial_x;
int player_partial_y;
int move_x;
int move_y;
byte buttons;
byte button_ack;
int rand_high;
byte rand_low;

class TPlayerData {
    byte[8] score;
    byte[4] bonus;
    byte[16] egg;
    byte[16] grain;
    int lives;
}


TPlayerData player_data;

class TDuckInfo {
    byte x;
    byte y;
    byte tile_x;
    byte tile_y;
    int mode;
    int dir;
}

TDuckInfo[5] duck;

int DuckSprite(int n)
{
    int dir;
    int sprite;

    TDuckInfo d=duck[n];
    dir = d.dir;
    switch (d.mode) {
    case DUCK_BORED:
        if (dir & DIR_HORIZ) {
            sprite = (dir == DIR_R) ? 0 : 2;
        }
        else {
            sprite = 4;
        }
        break;
    case DUCK_STEP:
        if (dir & DIR_HORIZ) {
            sprite = (dir == DIR_R) ? 1 : 3;
        }
        else {
            sprite = 5;
        }
        break;
    case DUCK_EAT2:
    case DUCK_EAT4:
        sprite = (dir == DIR_R) ? 6 : 8;
        break;
    case DUCK_EAT3:
        sprite = (dir == DIR_R) ? 7 : 9;
        break;
    default:
    trace("wrong value in switch");
    };
    return sprite;
}

/* Movement code generates out of bounds reads.  */
int Do_ReadMap(byte x, byte y)
{
    if (y >= 0x19 || x >= 0x14)
        return 0;
    if (y < 0 || x < 0)
        return 0;
    return levelmap[x + y * 20];
}

void Do_InitTile(int x, int y, int type)
{
    int old_type;

    old_type = levelmap[y * 20 + x];
    levelmap[y * 20 + x] = type;
}

vec2[] scene_array_xy;
vec2[] scene_array_uv;
int scene_verts;


void RenderScene()
{
    glVertexPointer(2, GL_FLOAT, 0, scene_array_xy);
    glTexCoordPointer(2, GL_FLOAT, 0, scene_array_uv);
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
    glDrawArrays(GL_QUADS, 0, scene_verts);
    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
    glDisableClientState(GL_VERTEX_ARRAY);
}

void AddSceneVert(float x, float y, float u, float v)
{
  int i=scene_verts;

  scene_verts++;

  scene_array_xy.SizeDim1=scene_verts;
  scene_array_xy[i]=vector2(x,y);

  scene_array_uv.SizeDim1=scene_verts;
  scene_array_uv[i]=vector2(u,v);
}

void AddSceneSprite(gltex t, float x, float y)
{
    AddSceneVert(x, y, t.x1, t.y1);
    AddSceneVert(x, y - t.h, t.x1, t.y2);
    AddSceneVert(x + t.w, y - t.h, t.x2, t.y2);
    AddSceneVert(x + t.w, y, t.x2, t.y1);
}

int[32] item_pos;
int item_count;

void RenderBackground()
{
    int player;
    int x;
    int y;
    int n;
    int type;
    gltex tex;

    scene_verts = 0;
    AddSceneSprite(gltex_score, 0, 0xf0);
    for (player = 0; player < num_players; player++) {
        x = player * 0x22 + 0x1b;
        AddSceneSprite(gltex_blank, x, 0xf0);
    }

    y = 0xe3;
    AddSceneSprite(gltex_player, 0, y + 1);
    AddSceneSprite(gltex_digit[current_player + 1], 0x1b, y);

    AddSceneSprite(gltex_level, 0x24, y + 1);
    n = current_level + 1;
    AddSceneSprite(gltex_digit[n % 10], 0x45, y);
    n /= 10;
    AddSceneSprite(gltex_digit[n % 10], 0x40, y);
    if (n > 10)
        AddSceneSprite(gltex_digit[n / 10], 0x3b, y);

    AddSceneSprite(gltex_bonus, 0x4e, y + 1);
    AddSceneSprite(gltex_digit[0], 0x75, y);
    AddSceneSprite(gltex_time, 0x7e, y + 1);

    item_count = 0;
    for (x = 0; x < 20; x++) {
        for (y = 0; y < 25; y++) {
            type = levelmap[y * 20 + x];
            if (type & TILE_LADDER) {
                tex = gltex_ladder;
            }
            else if (type & TILE_WALL) {
                tex = gltex_wall;
            }
            else if (type & (TILE_EGG | TILE_GRAIN)) {
                item_pos[item_count++] = y * 20 + x;
                continue;
            }
            else {
                continue;
            }
            AddSceneSprite(tex, x << 3, (y << 3) | 7);
        }
    }

    if (have_big_duck) {
        tex = gltex_cage_open;
    }
    else {
        tex = gltex_cage_closed;
    }
    AddSceneSprite(tex, 0, 0xdc);
}

void RenderDigit(int x, int y, int n)
{
    RenderSprite(gltex_digit[n], x, y);
}

void RenderPlayerHUD(int player)
{
    int x = player * 0x22 + 0x1b;
    int n;

    for (n = 0; n < 6; n++) {
        RenderDigit(x + 1 + n * 5, 0xef,
            player_data.score[n + 2]);
    }

    n = player_data.lives;
    if ((n > 8) || (n < 0))
        n = 8;
    while (n--) {
        RenderSprite(gltex_hat, x, 0xe7);
        x += 4;
    }
}

void RenderFrame() {
    int x;
    int y;
    int n;
    int sprite;
    int type;
    gltex tex;

    RenderScene();

    /* HUD  */
  RenderPlayerHUD(0);

    y = 0xe3;

    RenderDigit(0x66, y, bonus[0]);
    RenderDigit(0x6b, y, bonus[1]);
    RenderDigit(0x70, y, bonus[2]);

    RenderDigit(0x91, y, timer_ticks[0]);
    RenderDigit(0x96, y, timer_ticks[1]);
    RenderDigit(0x9b, y, timer_ticks[2]);

    /* Egg/Grain.  */
    for (n = 0; n < item_count; n++) {
        type = levelmap[item_pos[n]];
        if (type & TILE_EGG) {
            tex = gltex_egg;
        }
        else if (type & TILE_GRAIN) {
            tex = gltex_grain;
        }
        else {
            continue;
        }
        x = item_pos[n] % 20;
        y = item_pos[n] / 20;
        RenderSprite(tex, x << 3, (y << 3) | 7);
    }

    /* Ducks.  */
    for (n = 0; n < num_ducks; n++) {
        x = duck[n].x;
        sprite = DuckSprite(n);
        if (sprite >= 8)
            x -= 8;

    if(gltex_duck[sprite]!=null)
        RenderSprite(gltex_duck[sprite], x, duck[n].y);
    }

    /* Player.  */
    gltex[4] ps=null;
    if (player_face == 0) {
        ps = gltex_player_up;
        n = (player_y >> 1) & 3;
    }
    else {
        if (player_face < 0)
            ps = gltex_player_l;
        else
            ps = gltex_player_r;
        n = (player_x >> 1) & 3;
    }
    if (player_mode != cPLAYER_CLIMB) {
        if (move_x == 0)
            n = 0;
    }
    else {
        if (move_y == 0)
            n = 0;
    }
    RenderSprite(ps[n], player_x, player_y);

    /* Lift.  */
    if (have_lift) {
        for (n = 0; n < 2; n++) {
            RenderSprite(gltex_lift, lift_x, lift_y[n]);
        }
    }

    /* Big duck.  */
    if (big_duck_dir) {
        tex = big_duck_frame ? gltex_big_duck_l2 : gltex_big_duck_l1;
    }
    else {
        tex = big_duck_frame ? gltex_big_duck_r2 : gltex_big_duck_r1;
    }
    RenderSprite(tex, big_duck_x, big_duck_y);
}

int readFromArray(byte[] ar, ref int pos) {
  return ar[pos++];
}

void LoadLevel()
{
    int i;
    int tmp;
    int x;
    int y;
    int num_walls;
    int num_ladders;
    int num_grain;

    i = current_level >> 4;
    if (i > 8)
        i = 8;
    timer_ticks[0] = 9 - i;
    timer_ticks[1] = 0;
    timer_ticks[2] = 0;

    byte[] levelData;
    levels.getLevel(current_level & 7,levelData);

    int pos=0;
    num_walls = readFromArray(levelData,pos);
    num_ladders = readFromArray(levelData,pos);
    have_lift = readFromArray(levelData,pos);
    num_grain = readFromArray(levelData,pos);
    num_ducks = readFromArray(levelData,pos);;
    for (i = 0; i < 20 * 25; i++)
        levelmap[i] = 0;

    while (num_walls--) {
        y = readFromArray(levelData,pos);;
         x = readFromArray(levelData,pos);;
        i = readFromArray(levelData,pos);;
        while (x <= i) {
            Do_InitTile(x, y, TILE_WALL);
            x++;
        }
    }

    while (num_ladders--) {
        x = readFromArray(levelData,pos);;
        y = readFromArray(levelData,pos);;
        i = readFromArray(levelData,pos);;
        while (y <= i) {
            tmp = levelmap[x + y * 20];
            Do_InitTile(x, y, TILE_LADDER | tmp);
            y++;
        }
    }

    if (have_lift) {
        lift_x = readFromArray(levelData,pos) << 3;
    }

    eggs_left = 0;
    for (i = 0; i < 0xc; i++) {
        x = readFromArray(levelData,pos);;
        y = readFromArray(levelData,pos);;
        if (player_data.egg[i] == 0) {
            Do_InitTile(x, y, (i << 4) | TILE_EGG);
            eggs_left++;
        }
    }

    for (i = 0; i < num_grain; i++) {
        x = readFromArray(levelData,pos);;
        y = readFromArray(levelData,pos);;
        if (player_data.grain[i] == 0) {
            Do_InitTile(x, y, (i << 4) | TILE_GRAIN);
        }
    }

    for (i = 0; i < 5; i++) {
    TDuckInfo d=duck[i];
        d.tile_x = readFromArray(levelData,pos);;
        d.tile_y = readFromArray(levelData,pos);;
    }

    RenderBackground();
}

void StartLevel()
{
    int i;
    if (have_lift) {
        lift_y[0] = 8;
        lift_y[1] = 0x5a;
        current_lift = 0;
    }
    big_duck_x = 4;
    big_duck_y = 0xcc;
    big_duck_dx = big_duck_dy = 0;
    big_duck_frame = 0;
    big_duck_dir = 0;
    if ((current_level >> 3) == 1) {
        num_ducks = 0;
    }
    if (current_level >= 24) {
        num_ducks = 5;
    }
    for (i = 0; i < num_ducks; i++) {
        TDuckInfo d=duck[i];
        d.x = d.tile_x << 3;
        d.y = (d.tile_y << 3) + 0x14;
        d.mode = DUCK_BORED;
        d.dir = 2;
    }
    /* Delay(3) */
    player_x = 0x3c;
    player_y = 0x20;
    player_tilex = 7;
    player_tiley = 2;
    player_partial_x = 7;
    player_partial_y = 0;
    player_mode = cPLAYER_WALK;
    player_face = 1;
    button_ack = 0x1f;
}

/* Returns nonzero if blocked.  */
int MoveSideways()
{
    int tmp, x, y;
    tmp = move_x;
    if (tmp == 0)
        return 0;
    if (tmp < 0) {
        if (player_x == 0)
            return 1;
        if (player_partial_x >= 2)
            return 0;
        if (move_y == 2)
            return 0;

        x = player_tilex - 1;
        y = player_tiley;
        tmp = player_partial_y + move_y;
        if (tmp < 0)
            y--;
        else if (tmp >= 8)
            y++;
        if (Do_ReadMap(x, y) == 1)
            return 1;
        if (move_y >= 0)
            return 0;
        x = player_tilex - 1;
        y++;
        return (Do_ReadMap(x, y) == 1);
    }
    tmp = player_x;
    if (tmp >= 0x98)
        return 1;
    if (player_partial_x < 5)
        return 0;
    if (move_y == 2)
        return 0;
    x = player_tilex + 1;
    y = player_tiley;
    tmp = player_partial_y + move_y;
    if (tmp < 0)
        y--;
    else if (tmp >= 8)
        y++;
    if (Do_ReadMap(x, y) == 1)
        return 1;
    if (move_y >= 0)
        return 0;
    x = player_tilex + 1;
    y++;
    return (Do_ReadMap(x, y) == 1);
}

void RemoveGrain(int x, int y)
{
    Do_InitTile(x, y, 0);
}

void ScoreChange(int n, int oldval, int newval)
{
    player_data.score[n] = newval;
}

void AddScore(int n, int val)
{
    int oldval;

    while (n >= 0) {
        oldval = player_data.score[n];
        val += oldval;
        if (n == 3)
            extra_life++;
        if (val < 10) {
            ScoreChange(n, oldval, val);
            return;
        }
        ScoreChange(n, oldval, val - 10);
        val = 1;
        n--;
    }
}
/*        N    T  PI1  PI2  PI3  PN1  PN2  PN3   AA   AD   AS   AR  ALA  ALD */
/* E1: 0x01 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x7e 0xce 0x00 0x00 0x64 0x00
 * E2: 0x02 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x7e 0xfe 0x00 0xfb 0x7e 0x64
 * E3: 0x03 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x32 0x00 0x00 0xe7 0x64 0x00
 */
void beep(int tmp) /* 0x0c98 */
{
    /* channel = 13 (Flush), note = 1, pitch = tmp, duration = 0x0001 */
//  sound_start(tmp, 1);
}

void squidge(int tmp) /* 0x0ca8 */
{
    /* 0001 0003 0000 0004 */
//  sound_start(tmp, 0);
}

void AnimatePlayer()
{
    int tmp;
    int x, y;

    player_x += move_x;
    tmp = player_partial_x + move_x;
    if (tmp < 0)
        player_tilex--;
    if (tmp >= 8)
        player_tilex++;
    player_partial_x = tmp & 7;
    player_y += move_y;
    tmp = player_partial_y + move_y;
    if (tmp < 0)
        player_tiley--;
    if (tmp >= 8)
        player_tiley++;
    player_partial_y = tmp & 7;
    x = player_tilex;
    y = player_tiley;
    if (player_partial_y >= 4)
        y++;
    tmp = Do_ReadMap(x, y);
    if ((tmp & 0x0c) == 0)
        return;
    if ((tmp & 0x08) == 0) {
        /* Got egg */
        eggs_left--;
        /* SQUIDGE(6) */
        squidge(6);
        tmp >>= 4;
        player_data.egg[tmp]--;
        Do_InitTile(x, y, 0);
        tmp = (current_level >> 2) + 1;
        if (tmp >= 10)
            tmp = 10;
        AddScore(5, tmp);
    }
    else {
        /* Got grain */
        /* SQUIDGE(5) */
        squidge(5);
        tmp >>= 4;
        player_data.grain[tmp]--;
        RemoveGrain(x, y);
        AddScore(6, 5);
        bonus_hold = 14;
    }
}

void PlayerGrabLadder(int want_move)
{
    int tmp;
    int x;
    int y;

    tmp = player_partial_x + move_x;
    if (tmp != 3)
        return;
    if (want_move == 0)
        return;
    if (want_move > 0) {
        x = player_tilex;
        y = player_tiley + 1;
        tmp = Do_ReadMap(x, y);
        if ((tmp & 2) == 0) {
            if (player_partial_y >= 4)
                y++;
            tmp = Do_ReadMap(x, y);
            if ((tmp & 2) == 0)
                return;
        }
        player_mode = cPLAYER_CLIMB;
        tmp = player_partial_y + move_y;
        if (tmp & 1)
            move_y++;
        return;
    }
    x = player_tilex;
    y = player_tiley;
    tmp = Do_ReadMap(x, y);
    if ((tmp & 2) == 0)
        return;
    x = player_tilex;
    y = player_tiley + 1;
    tmp = Do_ReadMap(x, y);
    if ((tmp & 2) == 0)
        return;
    player_mode = cPLAYER_CLIMB;
    tmp = player_partial_y + move_y;
    if (tmp & 1)
        move_y--;
    return;
}

void PlayerHitLift()
{
    int tmp;
    int y1;
    int y2;

    if (!have_lift)
        return;
    if ((lift_x > player_x) || (lift_x + 10 < player_x))
        return;
    y1 = player_y - 0x11;
    y2 = player_y - 0x13 + move_y;
    tmp = lift_y[0];
    if (tmp > y1 || tmp < y2) {
        tmp = lift_y[1];
        if (tmp != y1)
        {
            if (tmp >= y1)
                return;
            if (tmp < y2)
                return;
        }
        if (current_lift == 0)
            tmp++;
    }
    else {
        if (current_lift != 0)
            tmp++;
    }
    tmp -= y1;
    move_y = tmp + 1;
    player_fall = 0;
    player_mode = cPLAYER_LIFT;
}

void PlayerJump()
{
    int tmp;
    int tmp2;
    int x;
    int y;

    move_x = player_slide;
    tmp2 = move_y;
    tmp = player_fall >> 2;
    if (tmp >= 6)
        tmp = 6;
    move_y = 2 - tmp;
    player_fall++;
    if (player_y == 0xdc) {
        move_y = -1;
        player_fall = 0x0c;
    }
    else {
        PlayerGrabLadder(tmp2);
        if (player_mode == cPLAYER_CLIMB)
            return;
    }

    tmp = move_y + player_partial_y;
    if (tmp == 0) {
        x = player_tilex;
        y = player_tiley - 1;
        tmp = Do_ReadMap(x, y);
        if ((tmp & 1) != 0)
            player_mode = cPLAYER_WALK;
    }
    else if (tmp > 0) {
        if (tmp == 8) {
            x = player_tilex;
            y = player_tiley;
            tmp = Do_ReadMap(x, y);
            if ((tmp & 1) != 0)
                player_mode = cPLAYER_WALK;
        }
    }
    else {
        x = player_tilex;
        y = player_tiley - 1;
        tmp = Do_ReadMap(x, y);
        if ((tmp & 1) != 0) {
            player_mode = cPLAYER_WALK;
            move_y = -player_partial_y;
        }
    }

    PlayerHitLift();
    if (player_mode == cPLAYER_LIFT)
        return;

    if (MoveSideways()) {
        move_x = -move_x;
        player_slide = move_x;
    }
}

void StartPlayerJump()
{
    int tmp;

    button_ack |= 0x10;
    player_fall = 0;
    player_mode = cPLAYER_JUMP;
    tmp = move_x;
    player_slide = tmp;
    if (tmp != 0)
        player_face = tmp;
    PlayerJump();
}

void MovePlayer()
{
    int x, y, tmp;

    move_x = 0;
    move_y = 0;
    if (buttons & BUTTON_RIGHT) {
        move_x++;
    }
    if (buttons & BUTTON_LEFT) {
        move_x--;
    }
    if (buttons & BUTTON_DOWN) {
        move_y--;
    }
    if (buttons & BUTTON_UP) {
        move_y++;
    }
    move_y <<= 1;
    switch (player_mode) {
    case cPLAYER_JUMP:
        PlayerJump();
        break;
    case cPLAYER_FALL:
        player_fall++;
        tmp = player_fall;
        if (tmp < 4) {
            move_x = player_slide;
            move_y = -1;
        }
        else {
            move_x = 0;
            tmp = player_fall >> 2;
            if (tmp > 3)
                tmp = 3;
            move_y = -(tmp + 1);
        }
        tmp = move_y + player_partial_y;
        if (tmp == 0) {
            x = player_tilex;
            y = player_tiley - 1;
            tmp = Do_ReadMap(x, y);
            if ((tmp & 1) != 0)
                player_mode = cPLAYER_WALK;
        }
        else if (tmp < 0) {
            x = player_tilex;
            y = player_tiley - 1;
            tmp = Do_ReadMap(x, y);
            if ((tmp & 1) != 0) {
                player_mode = cPLAYER_WALK;
                move_y = -player_partial_y;
            }
        }
        break;
    case cPLAYER_CLIMB:
        if ((buttons & BUTTON_JUMP) != 0) {
            StartPlayerJump();
            break;
        }
        if (move_x != 0 && player_partial_y == 0) {
            x = player_tilex;
            y = player_tiley - 1;
            tmp = Do_ReadMap(x, y);
            if ((tmp & 1) != 0) {
                move_y = 0;
                player_mode = cPLAYER_WALK;
            }
        }
        if (player_mode != cPLAYER_WALK) {
            move_x = 0;
            if (move_y != 0 && player_partial_y == 0) {
                if (move_y >= 0) {
                    x = player_tilex;
                    y = player_tiley + 2;
                    tmp = Do_ReadMap(x, y);
                    if ((tmp & 2) == 0)
                        move_y = 0;
                }
                else {
                    x = player_tilex;
                    y = player_tiley - 1;
                    tmp = Do_ReadMap(x, y);
                    if ((tmp & 2) == 0)
                        move_y = 0;
                }
            }
        }
        player_face = 0;
        break;
    case 4: /* On lift */
        if ((buttons & BUTTON_JUMP) != 0) {
            StartPlayerJump();
            break;
        }
        if (lift_x > player_x || lift_x + 9 < player_x) {
            player_fall = 0;
            player_slide = 0;
            player_mode = cPLAYER_FALL;
        }
        move_y = 1;
        if (move_x != 0)
            player_face = move_x;
        if (MoveSideways()) {
            move_x = 0;
        }
        if (player_y >= 0xdc)
            is_dead++;
        break;
    case cPLAYER_WALK:
        if (buttons & BUTTON_JUMP) {
            StartPlayerJump();
            break;
        }
        if (move_y) {
            if (player_partial_x == 3) {
                x = player_tilex;
                if (move_y >= 0)
                    y = player_tiley + 2;
                else
                    y = player_tiley - 1;
                tmp = Do_ReadMap(x, y);
                if ((tmp & 2) != 0) {
                    move_x = 0;
                    player_mode = cPLAYER_CLIMB;
                    break;
                }
            }
            move_y = 0;
        }
        tmp = player_partial_x + move_x;
        x = player_tilex;
        if (tmp < 0)
            x--;
        else if (tmp >= 8)
            x++;
        y = player_tiley - 1;
        tmp = Do_ReadMap(x, y);
        if ((tmp & 1) == 0) {
            /* Walk off edge */
            int n;
            n = (move_x + player_partial_x) & 7;
            if (n < 4) {
                x = 1;
                y = 1;
            }
            else {
                y = 0;
                x = -1;
            }
            player_slide = x;
            player_fall = y;
            player_mode = cPLAYER_FALL;
        }
        if (MoveSideways()) {
            move_x = 0;
        }
        if (move_x) {
            player_face = move_x;
        }
        break;
    default:
    trace("wrong value in switch");
    }
    AnimatePlayer();
}

void MakeSound()
{
    int tmp;
    if (!(move_x || move_y))
        return;
    if ((duck_timer & 1) != 0)
        return;
    switch (player_mode) {
    case 0:
        tmp = 64;
        break;
    case 1:
        tmp = 96;
        break;
    case 2:
        tmp = player_fall;
        if (tmp >= 0x0b) {
            tmp = 0xbe - (player_fall * 2);
        }
        else {
            tmp = 0x96 + (player_fall * 2);
        }
        break;
    case 3:
        tmp = 0x6e - (player_fall * 2);
        break;
    case 4:
        if (move_x == 0)
            return;
        tmp = 0x64;
        break;
    default:
    trace("wrong value in switch");
    }
    beep(tmp);
}

/* MoveLift */
void MoveLift()
{
    int y;

    if (!have_lift)
        return;
    y = lift_y[current_lift];
    y += 2;
    if (y == 0xe0)
        y = 6;
    lift_y[current_lift] = y;
    current_lift = 1 - current_lift;
}

int popcount(int val)
{
  int count=0;
  for(int i=0; i<32; i++) {
    count += (val&1);
    val>>=1;
  }
  return count;
}

void FrobRandom()
{
    int carry;

    carry = (((rand_low & 0x48) + 0x38) & 0x40) != 0;
    rand_high = (rand_high << 1) | carry;
    rand_low = (rand_low << 1) | ((rand_high >> 24) & 1);
}

void ReduceBonus()
{
    int n;
    int flag;

    n = 2;
    do {
        bonus[n]--;
        flag = ((bonus[n] & 0x80) != 0);
        if (flag) {
            bonus[n] = 9;
        }
        n--;
    } while (flag);
    if (bonus[0] + bonus[1] + bonus[2] == 0)
        zero_bonus = 1;
}

void MoveDucks()
{
    int tmp;
    int y;
    int x;
    int flag;
    int tmp2;
    int newdir;

    duck_timer++;
    if (duck_timer == 8) {
        /* Big Duck.  */
        duck_timer = 0;
        if (have_big_duck) {
            tmp = big_duck_x + 4;
            if (tmp < player_x) {
                if (big_duck_dx < 5)
                    big_duck_dx++;
                big_duck_dir = 0;
            }
            else {
                if (big_duck_dx > -5)
                    big_duck_dx--;
                big_duck_dir = 1;
            }
            tmp = player_y + 4;
            if (tmp >= big_duck_y) {
                if (big_duck_dy < 5)
                    big_duck_dy++;
            }
            else {
                if (big_duck_dy > -5)
                    big_duck_dy--;
            }
            tmp = big_duck_y + big_duck_dy;
            if (tmp < 0x28)
                big_duck_dy = -big_duck_dy;
            tmp = big_duck_x + big_duck_dx;
            if (tmp < 0 || tmp >= 0x90)
                big_duck_dx = -big_duck_dx;
        }
        big_duck_x += big_duck_dx;
        big_duck_y += big_duck_dy;
        big_duck_frame = big_duck_frame^1;
        return;
    }
    if (duck_timer == 4) {
        /* Update bonus/timer.  */
        if (bonus_hold) {
            bonus_hold--;
            return;
        }
        x = 2;
        do {
            timer_ticks[x]--;
            flag = (timer_ticks[x] & 0x80) != 0;
            if (flag)
                timer_ticks[x] = 9;
            x--;
        } while (flag);
        tmp = timer_ticks[0] + timer_ticks[1] + timer_ticks[2];
        if (tmp == 0) {
            trace("tmp==0");
            is_dead++;
            return;
        }
        tmp = timer_ticks[2];
        if (tmp != 0 && tmp != 5)
            return;
        if (zero_bonus)
            return;
        ReduceBonus();
        return;
    }
    if (current_duck == 0)
        current_duck = duck_speed;
    else
        current_duck--;
    if (current_duck >= num_ducks)
        return;
    /* Move little duck.  */
    TDuckInfo this_duck = duck[current_duck];
    if (this_duck.mode >= DUCK_EAT1) {
        /* Eat grain.  */
        if (this_duck.mode == DUCK_EAT2) {
            x = this_duck.tile_x - 1;
            y = this_duck.tile_y;
            if ((this_duck.dir & DIR_L) == 0)
                x += 2;
            tmp = Do_ReadMap(x, y);
            if ((tmp & 8) != 0) {
                player_data.grain[tmp >> 4]--;
                RemoveGrain(x, y);
            }
        }
    }
    else if (this_duck.mode == DUCK_BORED) {
        /* Figure out which way to go next.  */
        x = this_duck.tile_x;
        y = this_duck.tile_y;
        newdir = 0;
        tmp = Do_ReadMap(x - 1, y - 1);
        if ((tmp & 1) != 0)
            newdir = DIR_L;
        tmp = Do_ReadMap(x + 1, y - 1);
        if ((tmp & 1) != 0)
            newdir |= DIR_R;
        tmp = Do_ReadMap(x, y - 1);
        if ((tmp & 2) != 0)
            newdir |= DIR_DOWN;
        tmp = Do_ReadMap(x, y + 2);
        if ((tmp & 2) != 0)
            newdir |= DIR_UP;
        if (popcount(newdir) != 1) {
            tmp = this_duck.dir;
            if (tmp & DIR_HORIZ) {
                tmp = tmp^0xfc;
            }
            else {
                tmp = tmp^0xf3;
            }
            newdir &= tmp;
        }
        if (popcount(newdir) != 1) {
            tmp2 = newdir;
            do {
                FrobRandom();
                newdir = rand_low & tmp2;
            } while (popcount(newdir) != 1);
        }
        this_duck.dir = newdir;
        /* Check for grain to eat.  */
        tmp = this_duck.dir;
        if (tmp & DIR_HORIZ) {
            if (tmp == DIR_L)
                tmp = Do_ReadMap(x - 1, y);
            else
                tmp = Do_ReadMap(x + 1, y);
            tmp &= 8;
            if (tmp != 0) {
                this_duck.mode = DUCK_EAT1;
            }
        }
    }
    if (this_duck.mode >= DUCK_EAT1) {
        /* Eating.  */
        if (this_duck.mode == DUCK_EAT4)
            this_duck.mode = DUCK_BORED;
        else
            this_duck.mode++;
        return;
    }
    /* Walking.  */
    if (this_duck.mode == DUCK_STEP) {
        this_duck.mode = DUCK_BORED;
        flag = 1;
    }
    else {
        this_duck.mode = DUCK_STEP;
        flag = 0;
    }
    switch (this_duck.dir) {
    case DIR_L:
        this_duck.x -= 4;
        this_duck.tile_x -= flag;
        break;
    case DIR_R:
        this_duck.x += 4;
        this_duck.tile_x += flag;
        break;
    case DIR_UP:
        this_duck.y += 4;
        this_duck.tile_y += flag;
        break;
    case DIR_DOWN:
        this_duck.y -= 4;
        this_duck.tile_y -= flag;;
        break;
    default:
        trace("error 1");
    }
    return;
}

void MaybeAddExtraLife()
{
    if (extra_life == 0)
        return;
    extra_life = 0;
    player_data.lives++;
}

void CollisionDetect()
{
    int n;

    /* Little ducks */
    for (n = 0; n < num_ducks; n++) {
    TDuckInfo d=duck[n];
    int dx=(d.x - player_x) + 5;
    int dy=(d.y - 1) - player_y + 0xe;
        if (dx < 0x0b && dx>0 && dy>0 && dy < 0x1d)
            is_dead++;
    }
    /* Big duck */
    if (!have_big_duck)
        return;
    if ((big_duck_x + 4 - player_x + 5) >= 0x0b)
        return;
    if ((big_duck_y - 5 - player_y + 0x0e) >= 0x1d)
        return;
    is_dead++;
}

void SavePlayerState()
{
    int i;
    level[current_player] = current_level;
    for (i = 0; i < 4; i++)
        player_data.bonus[i] = bonus[i];
}

void ResetPlayer()
{
    int a;
    int i;
    a = current_level + 1;
    if (a >= 10)
        a = 9;
    player_data.bonus[0] = a;
    player_data.bonus[1] = 0;
    player_data.bonus[2] = 0;
    player_data.bonus[3] = 0;
    for (i = 0; i < 16; i++) {
        player_data.egg[i] = 0;
        player_data.grain[i] = 0;
    }
}

void RestorePlayerState()
{
    int y;
    current_level = level[current_player];
    for (y = 0; y < 4; y++) {
        bonus[y] = player_data.bonus[y];
    }
}

void PlayTune(int addr)
{
    /* Play tune 0x2f7c */
}

void start_game()
{
  player_data = new TPlayerData();

  for(int i=0; i<duck.SizeDim1; i++) {
    duck[i]=new TDuckInfo();
  }

    int i, j;
    num_players = active_players = cNUM_PLAYERS;
    for (i = 3; i >= 0; i--) {
        current_player = i;
        player_data.lives = 5;
        level[i] = 0;
        for (j = 0; j < 8; j++) {
            player_data.score[j] = 0;
        }
        ResetPlayer();
    }
    RestorePlayerState();
}

void SetupLevel()
{
    int arg;

    arg = current_level;
    have_big_duck = (arg > 7);
    duck_timer = 0;
    current_duck = 0;
    duck_speed = (arg < 32) ? 8 : 5;
    extra_life = 0;
    is_dead = 0;
    bonus_hold = 0;
    rand_high = 0x767676;
    rand_low = 0x76;
}





void initNewLevel() {
    SetupLevel();
    LoadLevel();
    StartLevel();
}

void initNewGame() {
  start_Game();
  initNewLevel();
}


void run_game_one_frame()
{
  if(player_data==null)
    return;

    int tmp;
    MovePlayer();
    MakeSound();
    MoveLift();
    MoveDucks();
    MaybeAddExtraLife();
    CollisionDetect();
    RenderFrame();

//  if ((buttons & 0x80) != 0)
//      goto new_game;
    if (is_dead != 0 || player_y < 0x11) {
        /* Died */
        SavePlayerState();
        PlayTune(0x2fa6);
        if (--player_data.lives == 0) {
            /* Clear Screen */
            /* "Game Over" */
            /* Highscores.  */
            initNewGame();
      return;
        }
        RestorePlayerState();
    initNewLevel();
    return;
    }
    if (eggs_left == 0 || cheat) {
        /* Level complete */
        while (!zero_bonus) {
            AddScore(6, 1);
            ReduceBonus();
            MaybeAddExtraLife();
        }
        /* Advance to next level */
        cheat = 0;
        zero_bonus = 0;
        current_level++;
        SavePlayerState();
        ResetPlayer();
        RestorePlayerState();
    initNewLevel();
    }
//  goto next_frame;
}]]>
      </Source>
    </ZLibrary>
    <ZExpression>
      <Expression>
<![CDATA[glDisable(GL_DEPTH_TEST);
glEnable(GL_TEXTURE_2D);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
glEnable(GL_BLEND);
glClearColor(0, 0, 0, 0);

LoadTextures();

initNewGame();]]>
      </Expression>
    </ZExpression>
  </OnLoaded>
  <OnUpdate>
    <ZExpression Expression="buttons=0;"/>
    <KeyPress Name="Kp1" Keys="POAQ ">
      <OnPressed>
        <ZExpression>
          <Expression>
<![CDATA[int c=ord(subStr(Kp1.Keys,Kp1.Keyindex,1));

switch(c) {
  case ord("Q") : buttons |= BUTTON_UP; break;
  case ord("A") : buttons |= BUTTON_DOWN; break;
  case ord(" ") : buttons |= BUTTON_JUMP; break;
  case ord("O") : buttons |= BUTTON_LEFT; break;
  case ord("P") : buttons |= BUTTON_RIGHT;break;
}]]>
          </Expression>
        </ZExpression>
      </OnPressed>
    </KeyPress>
    <ZExpression Comment="Joystick">
      <Expression>
<![CDATA[//Works with POV control (such as a Nintendo Switch Joy-Con)

float pov=joyGetPOV(0);
if(pov != -1 ) {
  const int range=45;

  if( (pov>= 90-range) && (pov<=90+range) )
    buttons |= BUTTON_RIGHT;
  else if( (pov>=270-range) && (pov<=270+range) )
    buttons |= BUTTON_LEFT;

  if( (pov>= 0-range) && (pov<=0+range) )
    buttons |= BUTTON_UP;
  else if( (pov>=180-range) && (pov<=180+range) )
    buttons |= BUTTON_DOWN;
}

if(joyGetButton(0,0) )
  buttons |= BUTTON_JUMP;]]>
      </Expression>
    </ZExpression>
  </OnUpdate>
  <OnRender>
    <ZExpression>
      <Expression>
<![CDATA[//adjust the camera a bit to center the game
glScalef(1.5,1.5,1.0);
glTranslatef(-80,-120,0);

run_game_one_frame();]]>
      </Expression>
    </ZExpression>
  </OnRender>
  <Content>
    <Camera Name="OrthoCamera" Kind="1" ClipNear="1" ClipFar="-1" OrthoZoom="200"/>
  </Content>
</ZApplication>
