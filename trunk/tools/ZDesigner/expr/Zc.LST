

Compiled: den 26 december 2008 - 12:01:12
Output sent to: D:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 26 december 2008 @ 12:01:12

Statistics:
  number of terminals:        74 (limit  2561)
  number of non-terminals:    28 (limit  1281)
  number of pragmas:           0 (limit  2487)
  number of symbolnodes:     102 (limit  2561)
  number of graphnodes:      255 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    24 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) ExprEdit
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;    
   16    PRIVATE
   17      CurrentFunction : TZcOpFunction;
   18      procedure WriteStr(S : string);
   19      procedure WriteOp(Op : TZcOp);
   20      procedure CleanUp;
   21      function NoFunctionsAllowed : boolean;
   22      procedure ZError(const S : string);
   23    CREATE
   24      ZFunctions := TObjectList.Create(False);
   25    DESTROY
   26      CleanUp;
   27    ERRORS
   28      200 : Result := 'Not a floating point value';
   29      201 : Result := 'Name already defined in this scope';
   30      202 : Result := 'Return value expected';
   31      203 : Result := 'Function should not return a value';
   32      204 : Result := 'Only function definitions are allowed here';
   33  END_DELPHI
   34  
   35  (* Arbitrary Code *)
   36  
   37  
   38  
   39  procedure T-->Grammar<--.WriteStr(S : string);
   40  begin
   41    StreamToListFile(S, TRUE);
   42  end;
   43  
   44  procedure T-->Grammar<--.WriteOp(Op : TZcOp);
   45  begin
   46    WriteStr(Op.ToString);
   47  end;
   48  
   49  
   50  procedure T-->Grammar<--.CleanUp;
   51  begin
   52    Zc_Ops.FunctionCleanUps.Clear;
   53    ZFunctions.Free;
   54  end;
   55  
   56  function T-->Grammar<--.NoFunctionsAllowed : boolean;
   57  begin
   58    Result := not AllowFunctions;
   59  end;
   60  
   61  procedure T-->Grammar<--.ZError(const S : string);
   62  var
   63    E : EParseError;
   64  begin
   65    E := EParseError.Create(S);
   66    E.Message := S;
   67    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   68    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   69    raise E;
   70  end;
   71  
   72  
   73  CHARACTERS
   74  
   75          tab                = CHR(9). /*  9 = tabulator */
   76          eol                = CHR(10). /* 10 = line feed */
   77          cr                 = CHR(13). /* 13 = carriage return */
   78          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   79  
   80          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   81          digit              = "0123456789".
   82          hexDigit           = digit + "ABCDEFabcdef".
   83          notDigit           = ANY - digit.
   84  
   85          char               = ANY - "'" - '\\' - newLine.
   86          verbatimStringChar = ANY - '"'.
   87          regularStringChar  = ANY - '"' - '\\' - newLine.
   88          notNewLine         = ANY - newLine .
   89  
   90  
   91  TOKENS
   92  
   93    /*--------------------------------------------------------------------------------*/
   94          intCon =
   95                  ( digit {digit}
   96                  | ("0x" | "0X") hexDigit {hexDigit}
   97                  )
   98                  ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
   99    /*--------------------------------------------------------------------------------*/
  100          realCon =
  101                  "." digit {digit}
  102                  [("e" | "E") ["+" | "-"] digit {digit}]
  103                  ["F" | "f" | "D" | "d" | "M" | "m"]
  104          | digit {digit}
  105                  ( "." digit {digit}
  106                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  107                          ["F" | "f" | "D" | "d" | "M" | "m"]
  108                  | ("e" | "E") ["+" | "-"] digit {digit}
  109                          ["F" | "f" | "D" | "d" | "M" | "m"]
  110                  | "F" | "f" | "D" | "d" | "M" | "m"
  111                  ).
  112    /*--------------------------------------------------------------------------------*/
  113          stringCon =
  114                  '"'    { regularStringChar }
  115                  '"'.
  116  
  117          ident = ['@'] letter { letter | digit }.
  118  
  119  
  120          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  121          and    = "&".
  122          assgn  = "=".
  123          colon  = ":".
  124          comma  = ",".
  125          dec    = "--".
  126          div    = "/".
  127          dot    = ".".
  128          eq     = "==".
  129          gt     = ">".
  130          gte    = ">=".
  131          inc    = "++".
  132          lbrace = "{".
  133          lbrack = "[".
  134          lpar   = "(".
  135          lshift = "<<".
  136          lt     = "<".
  137          lte    = "<=".
  138          minus  = "-".
  139          mod    = "%".
  140          neq    = "!=".
  141          not    = "!".
  142          or     = "|".
  143          plus   = "+".
  144          rbrace = "}".
  145          rbrack = "]".
  146          rpar   = ")".
  147          rshift = ">>".
  148          scolon = ";".
  149          tilde  = "~".
  150          times  = "*".
  151          xor    = "^".
  152  
  153  
  154  
  155  COMMENTS FROM "/*" TO "*/"
  156  COMMENTS FROM "//" TO eol
  157  
  158  IGNORE eol + cr + tab
  159  
  160  PRODUCTIONS
  161  
  162  /*------------------------------------------------------------------------*
  163   *--------------------------- Declarations -------------------------------*
  164   *------------------------------------------------------------------------*/
  165  
  166  Zc (. var 
  167          I : integer; 
  168          Func : TZcOpFunction; 
  169          Typ : TZcDataType;
  170      .)
  171  = 
  172  
  173    IF AllowFunctions THEN 
  174    BEGIN { 
  175      ("void" (. Typ := zctVoid; .) | Type<Typ> ) ident (. 
  176            if SymTab.Contains(LexString) then
  177              ZError('Name already defined: ' + LexString)
  178            else
  179            begin
  180              Func := TZcOpFunction.Create(GlobalNames);
  181              Func.Id := LexString;
  182              Func.ReturnType := Typ;
  183              SymTab.Add(Func.Id,Func);
  184              ZFunctions.Add(Func); 
  185              Self.CurrentFunction := Func;
  186              SymTab.PushScope;
  187            end;
  188         .)
  189      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  190          (. 
  191             SymTab.PopScope;
  192          .)
  193      } 
  194    END ELSE
  195    BEGIN
  196  
  197  
  198    (. 
  199         Func := TZcOpFunction.Create(nil);
  200         Func.ReturnType := Self.ReturnType;
  201         Self.CurrentFunction := Func;
  202         SymTab.PushScope;
  203         ZFunctions.Add(Func);
  204    .)
  205  
  206    /* A zc-expression is treated like the body of a nameless function
  207       to allow local var declarations  */
  208  
  209    ZcFuncBody
  210  
  211    (. 
  212         SymTab.PopScope;
  213    .)
  214    END
  215  
  216  (.  
  217         if Successful then
  218         begin
  219           for I:=0 to ZFunctions.Count-1 do
  220           begin
  221             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  222             //WriteOp(TZcOp(ZFunctions[I]));
  223           end;
  224         end;
  225  .)
  226  .
  227  
  228  /*------------------------------------------------------------------------*/
  229  
  230  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  231  =  {  (. Op:=nil; .)
  232        Statement<Op>
  233        (. if Op<>nil then
  234             CurrentFunction.Statements.Add(Op);
  235           Op := nil;
  236        .)
  237     }
  238  .
  239  
  240  /*------------------------------------------------------------------------*/
  241  FormalParams                    
  242  = ( Par ["," FormalParams] )
  243  .
  244  /*------------------------------------------------------------------------*/
  245  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  246  = Type<Typ> ident
  247       (.
  248          if SymTab.ScopeContains(LexString) then
  249            SynError(201)
  250          else
  251          begin
  252            Arg := TZcOpArgumentVar.Create(nil);
  253            Arg.Id := LexString;
  254            Arg.Typ := Typ;
  255            CurrentFunction.AddArgument(Arg);
  256            SymTab.Add(Arg.Id,Arg);
  257          end;
  258       .)
  259  .
  260  /*------------------------------------------------------------------------*/
  261  
  262  LocalVarDecl (. var Typ : TZcDataType; .)
  263  = Type<Typ> LocalVar<Typ> {"," LocalVar<Typ>}
  264  .
  265  
  266  /*------------------------------------------------------------------------*/
  267  
  268  LocalVar<Typ : TZcDataType> (. var Loc : TZcOpLocalVar; .)
  269  = ident  
  270       (. 
  271          if SymTab.ScopeContains(LexString) then
  272            SynError(201)
  273          else
  274          begin
  275            Loc := TZcOpLocalVar.Create(nil);
  276            Loc.Id := LexString;
  277            Loc.Typ := Typ;
  278            CurrentFunction.AddLocal(Loc);
  279            SymTab.Add(Loc.Id,Loc);
  280          end;
  281       .)
  282       /* [ "=" ( Init | "stackalloc" Type "[" Expr<Op> "]") ] */
  283  .
  284  
  285  /*------------------------------------------------------------------------*/
  286  
  287  /* Init           (. var Op : TZcOp; .)
  288  = Expr<Op>
  289  .  */
  290  
  291  /*------------------------------------------------------------------------*/
  292  Argument<var OutOp : TZcOp>
  293  = /* ["ref" | "out"] */
  294    Expr<OutOp>
  295  .
  296  
  297  /*------------------------------------------------------------------------*
  298   *-------------------------------- Types ---------------------------------*
  299   *------------------------------------------------------------------------*/
  300  
  301  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  302   * and for array creation expressions                                     */
  303  
  304  
  305  Type<var Typ : TZcDataType>
  306  = ( SimpleType<Typ> )
  307  .
  308  
  309  /*------------------------------------------------------------------------*/
  310  
  311  SimpleType<var Typ : TZcDataType>
  312  /* = IntType | "float" | "double" | "decimal" | "bool" */
  313  = "float" (. Typ := zctFloat; .) |
  314    "int" (. Typ := zctInt; .)
  315  .
  316  
  317  /*------------------------------------------------------------------------*/
  318  
  319  /* IntType
  320  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  321  . */
  322  
  323  
  324  /*------------------------------------------------------------------------*
  325   *------------------------------ Statements ------------------------------*
  326   *------------------------------------------------------------------------*/
  327  
  328  Statement<var OutOp : TZcOp>
  329  =
  330  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  331  (*IF IsLocalVarDecl THEN 
  332  BEGIN
  333    LocalVarDecl ";"
  334  END
  335  |  EmbeddedStatement<OutOp> *)
  336  
  337  LocalVarDecl ";"
  338  | EmbeddedStatement<OutOp>
  339    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  340     * ident {"." ident} { "[" ...                           */
  341  .
  342  
  343  /*------------------------------------------------------------------------*/
  344  EmbeddedStatement<var OutOp : TZcOp>
  345    (. var
  346         Op,IfOp,IfBody,ElseOp : TZcOp;
  347    .)
  348  = Block<OutOp>
  349  | ";"   (. OutOp := MakeOp(zcNop); .)
  350  | StatementExpr<OutOp> ";"
  351  | "if" (. ElseOp := nil; .)
  352    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  353          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  354  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  355  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  356  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  357  /* | "for" "(" [ForInit] ";" [Expr<Op>] ";" [ForInc] ")" EmbeddedStatement<Op> */
  358  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  359  /* | "break" ";" */
  360  /* | "continue" ";" */
  361   | (. Op := nil; .) "return" [ Expr<Op> ] ";"   
  362      (. 
  363          if (Op=nil) then
  364          begin
  365            if CurrentFunction.ReturnType<>zctVoid then
  366              SynError(202)
  367            else
  368              OutOp := MakeOp(zcReturn);
  369          end else
  370          begin
  371            if CurrentFunction.ReturnType=zctVoid then
  372              SynError(203)
  373            else
  374              //todo: testa rätt typ av returnvärde
  375              OutOp := MakeOp(zcReturn,[Op]);
  376          end;
  377      .)
  378  .
  379  /*------------------------------------------------------------------------*/
  380  
  381  Block<var OutOp : TZcOp>
  382    (. var
  383         Op : TZcOp;
  384    .)
  385  = (. OutOp := MakeOp(zcBlock); .)
  386    "{" {Statement<Op> (. OutOp.Children.Add(Op); .) } "}".
  387  
  388  /*------------------------------------------------------------------------*/
  389  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  390  =
  391    Unary<Op1>
  392    ( AssignOp<Kind> Expr<Op2>
  393      (.
  394        OutOp := MakeAssign(Kind,Op1,Op2);
  395      .)
  396    |                             (. OutOp := Op1; .)
  397    )
  398  .
  399  
  400  /*------------------------------------------------------------------------*/
  401  AssignOp<var Kind : TZcAssignType>
  402  = "="     (. Kind := atAssign; .)
  403    | "+="  (. Kind := atPlusAssign; .)
  404    | "-="  (. Kind := atMinusAssign; .)
  405    | "*="  (. Kind := atMulAssign; .)
  406    | "/="  (. Kind := atDivAssign; .)
  407  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  408  .
  409  
  410  /*------------------------------------------------------------------------*/
  411  
  412  /* SwitchSection   (. var Op : TZcOp; .)
  413  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  414  .  */
  415  
  416  /*------------------------------------------------------------------------*/
  417  
  418  /* SwitchLabel     (. var Op : TZcOp; .)
  419  = "case" Expr<Op> ":"
  420  | "default" ":"
  421  .  */
  422  
  423  /*------------------------------------------------------------------------*/
  424  
  425  /* ForInit     (. var Op : TZcOp; .)
  426  = LocalVarDecl
  427  | StatementExpr<Op> { "," StatementExpr<Op> }
  428  .  */
  429  
  430  /*------------------------------------------------------------------------*/
  431  
  432  /* ForInc      (. var Op : TZcOp; .)
  433  = StatementExpr<Op> { "," StatementExpr<Op> }
  434  .  */
  435  
  436  
  437  /*------------------------------------------------------------------------*
  438   *----------------------------- Expressions ------------------------------*
  439   *------------------------------------------------------------------------*/
  440  
  441  
  442  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  443  = Unary<Op1>
  444    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  445    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  446    )
  447  .
  448  /*------------------------------------------------------------------------*/
  449  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  450  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  451      {"||" Unary<Op> AndExpr<Op,R>
  452        (. OutOp := MakeOp(zcOr,[L,R]);
  453           L := OutOp; .)
  454      }
  455  .
  456  
  457  
  458  /*------------------------------------------------------------------------*/
  459  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  460  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  461      {"&&" Unary<Op> BitOrExpr<Op,R>
  462        (. OutOp := MakeOp(zcAnd,[L,R]);
  463           L := OutOp; .)
  464      }
  465  .
  466  /*------------------------------------------------------------------------*/
  467  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  468  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  469  .
  470  /*------------------------------------------------------------------------*/
  471  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  472  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  473  .
  474  /*------------------------------------------------------------------------*/
  475  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  476  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  477  .
  478  /*------------------------------------------------------------------------*/
  479  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  480  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  481    {( "!="   (. Kind := zcCompNE; .)
  482     | "=="   (. Kind := zcCompEQ; .)
  483     )
  484     Unary<Op> RelExpr<Op,R>
  485           (. OutOp := MakeBinary(Kind, L,R);
  486              L := OutOp;
  487           .)
  488    }
  489  .
  490  /*------------------------------------------------------------------------*/
  491  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  492  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  493    { ( "<"       (. Kind := zcCompLT; .)
  494      | ">"       (. Kind := zcCompGT; .)
  495      | "<="      (. Kind := zcCompLE; .)
  496      | ">="      (. Kind := zcCompGE; .)
  497       )
  498      Unary<Op> ShiftExpr<Op,R>
  499           (. OutOp := MakeBinary(Kind, L,R );
  500              L := OutOp;
  501           .)
  502    }
  503  .
  504  /*------------------------------------------------------------------------*/
  505  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  506  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  507  .
  508  /*------------------------------------------------------------------------*/
  509  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  510  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  511      {( "+"    (. Kind := zcPlus; .)
  512       | "-"    (. Kind := zcMinus; .)
  513       ) Unary<Op> MulExpr<Op,R>
  514           (. OutOp := MakeBinary(Kind,L,R);
  515              L := OutOp;
  516           .)
  517      }
  518  .
  519  /*------------------------------------------------------------------------*/
  520  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  521  =       (. OutOp := InOp; .)
  522    { ("*"      (. Kind := zcMul; .)
  523      | "/"     (. Kind := zcDiv; .)
  524    (*  | "%" *)
  525      ) Unary<Tmp>
  526           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  527              InOp := OutOp;
  528           .)
  529      }
  530  .
  531  /*------------------------------------------------------------------------*/
  532  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  533  =       (. LastOp := nil; .)
  534    {
  535      (
  536        (* "+" | *)
  537        "-"       (. Kind := zcNegate; .)
  538        (* | "!" | "~" | "*" | "++" | "--" *)
  539      )   (. Tmp := MakeOp(Kind);
  540             if LastOp<>nil then
  541               LastOp.Children.Add(Tmp);
  542             LastOp := Tmp;
  543          .)
  544    }
  545    Primary<Tmp>
  546      (. if LastOp<>nil then
  547         begin
  548           LastOp.Children.Add(Tmp);
  549           OutOp := LastOp;
  550         end else
  551           OutOp := Tmp;
  552      .)
  553  .
  554  /*------------------------------------------------------------------------*/
  555  Primary<var OutOp : TZcOp>         (. var Op : TZcOp; .)
  556  =            (. OutOp := nil; .)
  557    ( 
  558      ident    (. 
  559         OutOp := MakeOp(zcIdentifier,LexString); 
  560         if SymTab.Contains(LexString) then
  561           OutOp.Ref := SymTab.Lookup(LexString);
  562                .)
  563    | Literal  (. 
  564          try
  565            OutOp := TZcOpLiteral.Create(zctFloat,StrToFloat(LexString));
  566          except on EConvertError do
  567            SynError(200);
  568          end;
  569       .)
  570    | "(" Expr<OutOp> ")"
  571  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  572      | "float"  | "int"    | "long" | "object"  | "sbyte"
  573      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  574      ) "." ident *)
  575    )
  576  
  577    {
  578  /*  "++" | "--" | "->" ident
  579    | */
  580    "." ident (.
  581        Assert(OutOp.Kind=zcIdentifier);
  582        OutOp.Id := OutOp.Id + '.' + LexString;
  583      .)
  584    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  585             OutOp.Kind:=zcFuncCall;
  586           .)
  587          [Argument<Op> (. OutOp.Children.Add(Op); .)
  588            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  589            }
  590          ]
  591      ")"
  592  
  593    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  594             OutOp.Kind:=zcArrayAccess;
  595           .)
  596      Expr<Op> (. OutOp.Children.Add(Op); .) 
  597        {"," Expr<Op> (. OutOp.Children.Add(Op); .) } 
  598      "]" 
  599  
  600    }
  601  .
  602  /*------------------------------------------------------------------------*/
  603  Literal
  604  = intCon | realCon (* | stringCon | "true" | "false" | "null" *)
  605  .
  606  
  607  END Zc.

    1 LL(1) error
   11 warnings

