<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="ZGameEditor application" CameraPosition="0 0 30">
  <Content>
    <Group Comment="Bitmaps">
      <Children>
        <Bitmap Comment="Anti-Aliased Circle">
          <Producers>
            <BitmapExpression UseBlankSource="1">
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)

int BitmapSize = 64;
float AAWidth = 2;

// Default Pixel values

this.Pixel.R = 1;
this.Pixel.G = 1;
this.Pixel.B = 1;
this.Pixel.A = 0;

// Calculate the radius of the current Pixel from the center

float Radius = sqrt(pow(0.5-X-0.5/BitmapSize,2)+pow(0.5-Y-0.5/BitmapSize,2));

// Function for Pixels that are in the Anti-Aliased outer circle

if(Radius<0.5 && Radius>=0.5-AAWidth/BitmapSize){
  this.Pixel.A = (0.5-Radius)*BitmapSize/AAWidth;
}

// Aliased inner circle

if(Radius<0.5-AAWidth/BitmapSize){
  this.Pixel.A = 1;
}

this.Pixel.R *= this.Pixel.A;
this.Pixel.G *= this.Pixel.A;
this.Pixel.B *= this.Pixel.A;]]>
              </Expression>
            </BitmapExpression>
          </Producers>
        </Bitmap>
        <Bitmap Comment="Anti-Aliased Polygon">
          <Producers>
            <BitmapExpression UseBlankSource="1">
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)

// bitmap variables

int width = 128;
float aawidth = 2;

// algo variables

int sprockets = 7;
int centeroffset = 1;

// default color

this.pixel.r = 1;
this.Pixel.g = 1;
this.pixel.b = 1;
this.Pixel.A = 0;

//

// other variables

float this_angle;
int this_sprocket;
float normalx, normaly;
float distance;

float aadist = aawidth / width;
float angle =( 2 * PI )/ sprockets;
float maxdist = cos( angle / 2.0 )* 0.5;
float center = 0.5 -( 1.0 * centeroffset / width );

//

// determine angle of current pixel to center
if( this.x - 0.5 >= 0 )
  this_angle = atan2(( this.x - 0.5 ),( this.y - center ));
else
  this_angle = PI + atan2(( 0.5 - this.x ),( center - this.y  ));

// determine sprocket of current pixel
this_sprocket = (( this_angle )/ angle );

// calculate normal of current sprocket
normalx = sin(( angle * this_sprocket )+( angle / 2.0 ));
normaly = cos(( angle * this_sprocket )+( angle / 2.0 ));

// calculate distance of current pixel by dot product with normal
distance =(( this.x - 0.5 )* normalx )+(( this.Y - center )* normaly );

// set alpha accordingly
if( distance < maxdist ) this.pixel.a = ( maxdist - distance )/ aadist;

this.Pixel.R *= this.Pixel.A;
this.Pixel.G *= this.Pixel.A;
this.Pixel.B *= this.Pixel.A;]]>
              </Expression>
            </BitmapExpression>
          </Producers>
        </Bitmap>
        <Bitmap Comment="Bricks" Width="4" Height="4" Filter="2">
          <Producers>
            <BitmapExpression>
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)
float X1, Y1;

if (Y>0.5) {
 Y1 = Y*4-3; X1 = (X- 0.5)*2;
}
else {
 Y1 = Y*4-1; X1 = (abs(X-0.5)*2-1)*((X-0.5)*2+0.01)/abs((X-0.5)*2+0.01);
}
this.Pixel.B = pow(X1,8) + pow(Y1,8);
if (X1 > Y1) this.Pixel.G=1;]]>
              </Expression>
            </BitmapExpression>
            <BitmapZoomRotate Zoom="-4.5"/>
            <BitmapExpression>
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)
float Temp=0, Down = 0;

Temp = this.Pixel.B - pow(sin(X*pi),0.33)*noise2(X*3+768,Y+187)*1;
if (this.Pixel.G > 0.5) Down = 1;
this.Pixel = 0;
if (Temp < 0.7) {
    this.Pixel.G = clamp(pow(sin(X*pi),0.3),0,0.5) * noise2(X*15+500,Y*12+170);
    this.Pixel.R = 0.8 + noise2(X*35+350,Y*35)/3;
    if (noise2(X*35+350,Y*35) < -0.2) this.Pixel.R -= 0.1;
   if (noise2(X*35+350,Y*35) < -0.25) this.Pixel.R -= 0.3;
}
if (Temp < 0.7 && Temp > 0.45) {
    if (Down == 1) this.Pixel.R -= 0.3;
    else this.Pixel.R += 0.2;
}

if (Temp >= 0.7) {this.Pixel = 0.3 + noise2(X*130+2463,Y*130+374)/2;}
/*
if (this.Pixel.R > 0.2) {
    this.Pixel.R -= 0.2 + noise2(Y*12+2015,X*12+1021)/3;}

if (this.Pixel.G > 0.2) {
    this.Pixel.G = 0.1 + noise2(Y*12+715,X*12+321)/4;}

if (this.Pixel.B > 0.2) {
    this.Pixel.R += 0.1;
    this.Pixel.G += 0.2 + noise2(Y*12+203,X*12+821)/3;
    this.Pixel.B = 0;
}

if (this.Pixel.A > 0.2) {
    this.Pixel.R -= 0.3 + noise2(Y*12+2015,X*12+1021)/4;
    this.Pixel.A = 0;

}

if (this.Pixel.R < 0.2) {
    this.Pixel = 0.3 + noise2(Y*130+374,X*130+2463)/2;}]]>
              </Expression>
            </BitmapExpression>
            <BitmapZoomRotate Zoom="-1.5"/>
          </Producers>
        </Bitmap>
        <Bitmap Comment="Dithering">
          <Producers>
            <BitmapExpression UseBlankSource="1">
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)

float C, F, S, R, G, B;

C = 9/16-X/8; // Low contrast gradient ( less colors available then preferable )

R = C;
G = C;
B = C;

F = frac(C*255);
S = 1/255; // 1-bit offset ( on a 8-bit value )

if(frac(F) < 0.25)R += S;
if(frac(F) < 0.50)G += S;
if(frac(F) < 0.75)B += S;

this.Pixel.R = R;
this.Pixel.G = G;
this.Pixel.B = B;]]>
              </Expression>
            </BitmapExpression>
          </Producers>
        </Bitmap>
        <Bitmap Comment="Superformula" Width="4" Height="4">
          <Producers>
            <BitmapExpression Comment="2D Superformula">
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)

//Parameters
float VarM = 3;
float VarN1 = 5;
float VarN2 = 18;
float VarN3 = 18;

//Variables
float VarR, VarT, VarX, VarY, VarTemp;


if (this.X!=0 || this.Y!=0) { //this is always true (textures are multiples of 2x2)
    VarX = (this.X-0.5)*7;  //Use the constant multiplying the expression
    VarY = (this.Y-0.5)*7;  //to scale your image (zoom in and out) ;)
    VarT = atan2(VarY,VarX);
    VarR = sqrt(VarX*VarX + VarY*VarY);
    VarTemp = VarR - pow(
        pow(abs(cos(VarM*VarT/4)/1),VarN2) +
        pow(abs(sin(VarM*VarT/4)/1),VarN3),
        -1/VarN1);

    if (VarTemp < 0) { //If it does belong to the figure
            this.Pixel.G = VarTemp*(-2.5);
            //The higher the multiplyer is,
            //the sharper the image :)
            //If you need a very sharp image just use:
            //this.Pixel.G = 1;
            }
}   // X or Y different by zero
    //Else is not needed since X or Y will be never equal to zero. if it happens, just add them]]>
              </Expression>
            </BitmapExpression>
          </Producers>
        </Bitmap>
      </Children>
    </Group>
    <Group Comment="Meshes">
      <Children>
        <Mesh Comment="Improved Sphere">
          <Producers>
            <MeshBox Scale="1 0.5 1" XCount="31" YCount="15" Grid2DOnly="255"/>
            <MeshExpression AutoNormals="0">
              <Expression>
<![CDATA[//

        float E, A, C, X, Y, Z;

        // Convert range to radians

        E = this.V.Y*PI; // Elevation
        A = this.V.X*PI; // Azimuth

        // Convert spherical coordinates into cartesian

        C = cos(E);

        X = sin(A)*C;
        Y = sin(E);
        Z = cos(A)*C;

        // Assign coordinates

        this.V.X = X/2;
        this.V.Y = Y/2;
        this.V.Z = Z/2;

        this.N.X = X;
        this.N.Y = Y;
        this.N.Z = Z;]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Capsule">
          <Producers>
            <MeshBox Scale="0.5 0.5 1" XCount="15" Grid2DOnly="255"/>
            <MeshExpression AutoNormals="0">
              <Expression>
<![CDATA[float RX, SX, CX;

RX = this.V.X*PI*2;

SX = sin(RX); CX = cos(RX);

this.V.X = SX/2;
this.V.Z = CX/2;

this.N.X = this.V.X;
this.N.Y = 0;
this.N.Z = this.V.Z;]]>
              </Expression>
            </MeshExpression>
            <MeshBox Scale="0.5 0.5 1" XCount="15" YCount="3" Grid2DOnly="255"/>
            <MeshExpression AutoNormals="0">
              <Expression>
<![CDATA[float RX, SX, CX,
      RY, SY, CY;

RX = this.V.X*PI*2;
RY = this.V.Y*PI/2-PI/4;

SX = sin(RX); CX = cos(RX);
SY = sin(RY); CY = cos(RY);

this.V.X = SX*CY/2;
this.V.Y = SY/2;
this.V.Z = CX*CY/2;

this.N.X = this.V.X;
this.N.Y = this.V.Y;
this.N.Z = this.V.Z;

this.V.Y -= 0.5;]]>
              </Expression>
            </MeshExpression>
            <MeshCombine/>
            <MeshBox Scale="0.5 0.5 1" XCount="15" YCount="3" Grid2DOnly="255"/>
            <MeshExpression AutoNormals="0">
              <Expression>
<![CDATA[float RX, SX, CX,
      RY, SY, CY;

RX = this.V.X*PI*2;
RY = this.V.Y*PI/2+PI/4;

SX = sin(RX); CX = cos(RX);
SY = sin(RY); CY = cos(RY);

this.V.X = SX*CY/2;
this.V.Y = SY/2;
this.V.Z = CX*CY/2;

this.N.X = this.V.X;
this.N.Y = this.V.Y;
this.N.Z = this.V.Z;

this.V.Y += 0.5;]]>
              </Expression>
            </MeshExpression>
            <MeshCombine/>
          </Producers>
        </Mesh>
        <Mesh Comment="Cylinder">
          <Producers>
            <MeshSphere Name="OrigSphere"/>
            <MeshExpression AutoNormals="0">
              <Expression>
<![CDATA[//V : current vertex
//VarP is set to the number of Z samples;
//VarQ is the number of circonferences wanted in the upper and lower faces
float VarP;
int VarQ = 1;
float Psi;

VarP = OrigSphere.ZSamples;
if (this.V.Y != 0 || this.V.X != 0) {
    Psi = atan2(this.V.Y,this.V.X);
    this.V.X = cos(Psi); //*pow(1-abs(this.V.Z),2);
    this.V.Y = sin(Psi);
    //Normals
    //this.N.X = cos(Psi);
    //this.N.Y = sin(Psi);
    
    if (VarQ == 0) {
        this.V.Z /= 1 - 2/(VarP-1);
        }
    else { //VarQ != 0
        this.V.Z /= 1 - (VarQ+1)*2/(VarP-1);
        if (abs(this.V.Z)>1.001) {   //this is because we are using floating point precision
                                     //it is better to avoid stuff like "Z > 1" due to truncament errors

            //remember: tallest's high: (1/(1 - (VarQ+1)*2/(VarP-1));
            this.V.X *= 1 - (abs(this.V.Z)-1)/(1/(1 - (VarQ+1)*2/(VarP-1))-1);
            this.V.Y *= 1 - (abs(this.V.Z)-1)/(1/(1 - (VarQ+1)*2/(VarP-1))-1);

            this.V.Z = this.V.Z/(abs(this.V.Z));

        }
    } //ELSE

    //Normals
    if (abs(this.V.Z) < 0.999) {
        this.N.Z = 0; //lateral surface
        }
    else {
        if (pow(this.V.X,2) + pow(this.V.Y,2) < 0.999) {
               this.N.X = 0;  //Upper surface
               this.N.Y = 0;
               }
        else {
                 //Edges normals, you can decide what to use.
        }
    }  // End of normals section
    
    //soft edges      Work In Progress
    /*
    if (abs(this.V.Z) > 0.7 && pow(this.V.X,2) + pow(this.V.Y,2) > 0.7) {
        this.V.Z *= 0.9;
        this.V.Y *= 0.9;
        this.V.X *= 0.9;
        }
    // */

} //OUTER IF]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Perycicloid">
          <Producers>
            <MeshBox XCount="15" YCount="400" Grid2DOnly="255"/>
            <MeshExpression>
              <Expression>
<![CDATA[//V : current vertex
this.V.Z = 0;
               //HERE SHOULD BE 2*PI but the grid ranges between -1 and 1
float VarM = -4/3;
float VarP = this.V.X*PI;
float VarQ = this.V.Y*PI;

//this.V.X = 0.5*cos(VarP);

VarQ = this.V.X*PI;
VarP = this.V.Y*PI*3;
//this.V.X = (2 + 0.5*cos(VarQ))*cos(VarP);
//this.V.Y = (2 + 0.5*cos(VarQ))*sin(VarP);
this.V.Z = (0.1*sin(VarQ));
this.V.X = ((2)*(1 + VarM)*cos(VarM*VarP)-(2 + 0.1*cos(VarQ))*(VarM)*cos(VarP + VarM*VarP));
this.V.Y = ((2)*(1 + VarM)*sin(VarM*VarP)-(2 + 0.1*cos(VarQ))*(VarM)*sin(VarP + VarM*VarP));

/*         0.1*cos(VarP) +
           0.1*sin(VarP) +]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Pillow">
          <Producers>
            <MeshBox XCount="16" YCount="16" Grid2DOnly="255"/>
            <MeshExpression>
              <Expression>
<![CDATA[//V : current vertex
//N : current normal (turn off AutoNormals when modifying normals)
//C : current color (turn on VertexColors)

float V = this.V.X*PI;
float U = this.V.Y*PI;

this.V.X = cos(U);
this.V.Y = cos(V);
this.V.Z = 0-((sin(U)*sin(V))/Pi*2);]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Teardrop">
          <Producers>
            <MeshBox XCount="16" YCount="16" Grid2DOnly="255"/>
            <MeshExpression>
              <Expression>
<![CDATA[//V : current vertex
//N : current normal (turn off AutoNormals when modifying normals)
//C : current color (turn on VertexColors)

float V = this.V.X*PI;
float U = this.V.Y*PI;

this.V.X = 0.5*(1-cos(U))*sin(U)*cos(V);
this.V.Y = 0.5*(1-cos(U))*sin(U)*sin(V);
this.V.Z = cos(U);]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Throcoid">
          <Producers>
            <MeshBox XCount="15" YCount="500" Grid2DOnly="255"/>
            <MeshExpression>
              <Expression>
<![CDATA[//V : current vertex
this.V.Z = 0;
               //HERE SHOULD BE 2*PI but the grid ranges between -1 and 1
float VarM = 5/4;
float VarP = this.V.X*PI;
float VarQ = this.V.Y*PI;

//this.V.X = 0.5*cos(VarP);

VarQ = this.V.X*PI;
VarP = this.V.Y*PI*4;
//this.V.X = (2 + 0.5*cos(VarQ))*cos(VarP);
//this.V.Y = (2 + 0.5*cos(VarQ))*sin(VarP);
this.V.Z = 0-(0.1 * sin(VarQ));
this.V.X = ((2)*(1 + VarM)*cos(VarM*VarP)-(2+0.07*cos(VarQ))*(1 + VarM)*cos(VarP + VarM*VarP));
this.V.Y = ((2)*(1 + VarM)*sin(VarM*VarP)-(2+0.07*cos(VarQ))*(1 + VarM)*sin(VarP + VarM*VarP));]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Torus">
          <Producers>
            <MeshBox XCount="17" YCount="26" Grid2DOnly="255"/>
            <MeshExpression>
              <Expression>
<![CDATA[//V : current vertex
this.V.Z = 0;
               //HERE SHOULD BE 2*PI but the grid ranges between -1 and 1
float VarU = this.V.Y*PI;
float VarV = this.V.X*PI;
this.V.X = (2 + 0.5*cos(VarV))*cos(VarU);
this.V.Y = (2 + 0.5*cos(VarV))*sin(VarU);
this.V.Z = 0-(0.5*sin(VarV));]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Spring">
          <Producers>
            <MeshBox XCount="16" YCount="40" Grid2DOnly="255"/>
            <MeshExpression>
              <Expression>
<![CDATA[//V : current vertex
//N : current normal (turn off AutoNormals when modifying normals)
//C : current color (turn on VertexColors)

float V = this.V.X*PI;
float U = this.V.Y*PI;

float Radius=1;
float Length=4;
float Period=2;

this.V.X = (Pi+Radius*cos(V))*cos(U*Length);
this.V.Y = (Pi+Radius*cos(V))*sin(U*Length);
this.V.Z = 0-(Radius*(sin(V)+Period*U*Length/Pi));]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
        <Mesh Comment="Superformula">
          <Producers>
            <MeshSphere ZSamples="8" RadialSamples="60"/>
            <MeshExpression Comment="3D Superformula">
              <Expression>
<![CDATA[//V : current vertex
//N : current normal (turn off AutoNormals when modifying normals)
//C : current color (turn on VertexColors)
//Parameters
float VarM = 3;
float VarN1 = 5;
float VarN2 = 18;
float VarN3 = 18;

//Variables
float VarR, VarT, VarX, VarY, VarTemp;

if (this.V.X!=0 || this.V.Y!=0) { //this is always true (textures are multiples of 2x2)
    VarT = atan2(this.V.Y,this.V.X);
    VarR = pow(
        pow(abs(cos(VarM*VarT/4)/1),VarN2) +
        pow(abs(sin(VarM*VarT/4)/1),VarN3),
        -1/VarN1);

    VarR *= 0.5; //SCALING
    this.V.Y *= VarR;
    this.V.X *= VarR;

/* also, try doing something like:
    this.V.Y /= VarR;
    this.V.X /= VarR;
    */
    
}   // X or Y different by zero

this.V.Z *= 0.3;]]>
              </Expression>
            </MeshExpression>
          </Producers>
        </Mesh>
      </Children>
    </Group>
    <Group Comment="Models">
      <Children>
        <Model Comment="Ring from Cubes" Scale="0.1 0.1 0.1">
          <Definitions>
            <Mesh Name="Mesh_Box">
              <Producers>
                <MeshBox/>
              </Producers>
            </Mesh>
          </Definitions>
          <OnRender>
            <Repeat Count="100">
              <OnIteration>
                <RenderTransform Rotate="0 0 0.01"/>
                <RenderTransformGroup Comment="Translate.X determines Ring Size" Translate="0 30 0">
                  <Children>
                    <RenderMesh Mesh="Mesh_Box"/>
                  </Children>
                </RenderTransformGroup>
              </OnIteration>
            </Repeat>
          </OnRender>
        </Model>
        <Model Comment="Zwidget">
          <Definitions>
            <Bitmap Name="zWidgetXbmp" Width="4">
              <Producers>
                <BitmapFromFile Comment="Imported from X.gif">
                  <BitmapFile>
<![CDATA[78DAED9D416EC3300C0485222F28720CFAFF7714F9577B2DD2D6B025924B8AB3D03151627136B2649119C34B5FE383463369A39A2A7E67044EC08F800AF81168013F0230E0476006FC08D8801F811CF023C0037ED41C3FE0476D2D00FCA8AD05801FB5B54073F86F6FB7B40D0B003FFC6301E0877F2C00FCF08F05847D2EE62FE44C7F80FFFC81B66566FDBA267A489BFEF393B7E7E7F3777325FCF813E5FCE709B4556F2BFD4C67B1654E7F83FF2A815EEFD0A487C561C97CFF0FFF92409F7FCBE2AFB7646492273ECF21FAE28BB917FC67AEC7C723C3FA372CD0573F45BB82B834C7E54FFC4FC87F92FD9FB0405F7DD744FF92912951F502FEE5819EBB65126E9F9E9CEC4A947C99BE639FE6BFD6FE7F40A0A7670D15FC67AEBA4ABDA39328DEDFEF3DF90F08F4CAC4A182FF78D62B54EFCB64C7E6522BCDBF47A017E70E09FC07975FABD81DFCCB03BD6E1F09FC7F0E42B94A8FF02F0FB4898324F01F8FCCA82073BC0D0D926DAC9C026D65A2F38B62F322BD756BFCC27F4CA0034A464F3CA7837FF8DF867FDB6F02FFF05F8E7F0978A5FFE300FEE581365C47B0FE75E57FEE18E7558BB1FE2DB405F4320ED5F73FE13F3ED0B6FB9F9116D8EFF917FCC707DAFCF9578C05B63CFFC0FD7F7CA03DCE3F045860CBF36FF01F1F68A7F36FAE16D8F5FC33FCC707DAEFFCB393053AE4BFC0FFD822FFC5DC024DF21F85D893FFE801B3EDA38AEDF3DF9BF31F19E880FC772B0BEC5DFF04FE93075A5B02C8EA745009FE6D13018AD63F4C15686D0938AB350EFC27E73F67A0E5BD691F73C07FFE1F7FBF406728015DEE6027FCEFF133C55F00E4E49FFAFFA5E1C702F0DF1C7E2C00FFCDE1C702A839FC580035871F0BA0E6F06301D41C7E2C80000F0B2090C302A8396C580035C70C0BA0E6806101D41C2D2C809A43850550739C16EB57D368019905DF2332FEF5]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Material Name="zWidgetXmat" Light="0" Blend="2" ZBuffer="0" DrawBackFace="255">
              <Textures>
                <MaterialTexture Texture="zWidgetXbmp" TextureWrapMode="2" TexCoords="1"/>
              </Textures>
            </Material>
            <Bitmap Name="zWidgetYbmp" Height="4">
              <Producers>
                <BitmapFromFile Comment="Imported from Y.gif">
                  <BitmapFile>
<![CDATA[78DAEDDD5D6EC230104651ABEA0A2A1EABEE7F1D15FBFAFA8A68098E3DBFF446514521E0331609633BD28CE1B6E9E66FBB4D0F1EB7C3B70B41279F6F816F11828C8E298B2F1B829C8F2F852F158292DE9B8E4F0F41C53E27B15175C60787A0869F1CD6843AE35D5B51E7F3EB202536D95D43D0E14B4E7EAB109EE6F37EFEFD102AA458EA8C5F96541B62A833FE94AAF2105B9DF1331773F3B614F563EA94122B24D9F64B99E49F8FB9E6F3F21F2FF4F50FFFFEC18F1F3F7EFCF8F1E3C78F1FFF7FF04FCE70D6F49F9AA4ADE65F9867AEE3FF0D760D41D62B1D7F52FD4290E932FA01D22904D92DD3CCAC07998720A37B302661E621C8628DE914C936046DDFC0B380310C417B0B64CB0CAB10B471F7D726C02404ADAEEE19F6DE7E27ECB46B78ED8AF7A7A7D96A7B7F3B7EFCF8F1E3C78F1F3F7EFCF8F1E3C78F1F3F7EFCF8F1E3C78F1F3F7EFCF8F1E3C78F1F3FFEAAFEF7B7F7B23B7EFCF8E7FDD7EFEBEFDD5578DC22FE5EFEF926EEE25A3BE051E77C7E7DB6F677EF7FD7EBE7BE3FE5FA7FF9B8B4F63FFD26CCEFF85FD8BFCF330C103F7EFC86FEB534F26C17E17F553FE72FFEC9FC07FF7E5E87BFAFDF76205070FE133F7EE6FFF16FFA59FFC58F1F3F7EFCF8F1E3C78F1F3F7EFCF8F1E3C78F1F3F7EFCF8F1E3AFE85748E7E0C78F1F3F7EFCF8F1E3C78F1F3F7EFCF8F7F11DEB878615DF1CFEF52B7BD50F0D2EBE3942EA57B6A81F9A527C7304D6AF2C5B3F34B1F8E6082F2058AA7E687AF1CD91547D32BD7E6891E29BA340E9D2F8FAA1758A6F6EFA2BA4D9ACDFE1C78FFF25FD4DC7EFF8E73FFFEE4123BF0EFF2DEED7F49305FD5A7AA9885FDB0724FA657A587CA6ED7470805F3EDF34ABDDA93355C02FCF8B95B73FEBBB6735B61D19E7BE893FF257CFDC1F933239F9BDF36D577FC060506EFEB091AC1CFCC1C37099FA53E61064E44F9C00D1B63F7DF64649EF4D0FA1D4BC993AE3177E176A6EEA8C9FBC22D5DFD419FF88DA6E965E9DF1B76C67FC0FE5192B06]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Material Name="zWidgetYmat" Light="0" Blend="2" ZBuffer="0" DrawBackFace="255">
              <Textures>
                <MaterialTexture Texture="zWidgetYbmp" TextureWrapMode="2" TexCoords="1"/>
              </Textures>
            </Material>
            <Bitmap Name="zWidgetZbmp" Width="4">
              <Producers>
                <BitmapFromFile Comment="Imported from Z.gif">
                  <BitmapFile>
<![CDATA[78DAED9D416EC3300C0485A22F28720CFAFF7714F9177B6FDAC291457A579C858E8114786761DAA1943152150CC6E9612ADF6F8E0009F81138013F022AE047A005FC08C0801F8119F02360037E0472C08FDA8207FCA82D7EC08FDA4600F851DB08F485FFFDED5D761001E0877F2220B9CA269DB1F02FEC6908470CFEE1BFC0D350BDBFC03FFCD7781A7AF03F5FAE1DEAFFC7D7E379A412FEFF8A1755DD829E86EA6CF61180FF661188B46B15F0BF1DFF71C5BA79E8C64697ABA8FEFF15D11FB998FBC05FE1BA7FDEAF7EFF7989A747960B31F8ED2320C8BFC6FBFF7A4F0FAE1562F07B3F08C0BF8CA7C7D70A31F88D23305DB14FF36FF5FB6FA5A72F2D1462F0BB56410751BC7DDCDAF31F4AFC8F9C3B45BB082C7963F3D270EBFF29F37462895082DF3202F02FE3E9DCFCA104BFDF8300FCCB783A3D7F28C16F1681E5782F0C88D8A5CAF6F4CCE4A104BF531504FF329E9E9C398EC15FD6CBE71101F82FF434BBA13492BFC3867701F82FF4B4A0A13A94F81FF0BF1DFF4398FF387C17E0597886FFB936CE5723E6B0FF37C3D325F5FFD08B80741504FF329EAE7AFF4304E0DFD1D385EFFF8900F5BF9DA76B7FFF158F00FC6FC0FFB89A7FC11638B308C0BF8CA719FD9F6A1190AB82F2FA7C5AF21F55FC6B6E81F18B800EFFCEE71F2EF1346FFF1711807F7D4F53F7FF2A4700FE37E07F94F0AF7CA0A26504D61EDD73BEE7DFFCFCE725DD62D9E82E3FFCD0F5F04FF8F7F1546D36F887FF324F058FC0857FF8AFF154F608F41DC4F9E7F20F14D6F3C33FFC8BC3C9FF7FC17F5BF889006A0E3F1140CDE12702A839FC440035879F0820C0230208E488006A0E1B1140CD312302A83960440035478B08A0E6501101D41CA76030C4F77A7C03E998D25E]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Material Name="zWidgetZmat" Light="0" Blend="2" ZBuffer="0" DrawBackFace="255">
              <Textures>
                <MaterialTexture Texture="zWidgetZbmp" TextureWrapMode="2" TexCoords="1"/>
              </Textures>
            </Material>
          </Definitions>
          <OnRender>
            <UseMaterial Material="zWidgetXmat"/>
            <RenderTransform Scale="4 1 1"/>
            <RenderSprite/>
            <UseMaterial Material="zWidgetYmat"/>
            <RenderTransform Scale="0.25 4 1"/>
            <RenderSprite/>
            <UseMaterial Material="zWidgetZmat"/>
            <RenderTransform Scale="4 0.25 1" Rotate="0 0.75 0"/>
            <RenderSprite/>
          </OnRender>
        </Model>
      </Children>
    </Group>
    <Group Comment="Examples">
      <Children>
        <AppState Comment="2D Culling">
          <OnStart>
            <SpawnModel Model="MyCamera" SpawnStyle="1"/>
            <Repeat Comment="X">
              <OnIteration>
                <Repeat Comment="Y">
                  <OnIteration>
                    <SpawnModel Name="Spawn" Model="Building" Position="8 8 0"/>
                  </OnIteration>
                  <WhileExp>
<![CDATA[//

Spawn.Position.Y = this.Iteration;

//

return this.Iteration < 8;]]>
                  </WhileExp>
                </Repeat>
              </OnIteration>
              <WhileExp>
<![CDATA[//

Spawn.Position.X = this.Iteration;

//

return this.Iteration < 8;]]>
              </WhileExp>
            </Repeat>
          </OnStart>
          <OnUpdate>
            <Group Comment="kbInput">
              <Children>
                <Group Comment="Reset">
                  <Children>
                    <ZExpression>
                      <Expression>
<![CDATA[//

for(int U=0; U<kbInput.SizeDim1; ++U)
{
  kbInput[U] = 0;
}]]>
                      </Expression>
                    </ZExpression>
                  </Children>
                </Group>
                <Group Comment="Press">
                  <Children>
                    <KeyPress Comment="Right" Keys="&gt;">
                      <OnPressed>
                        <ZExpression>
                          <Expression>
<![CDATA[//

kbInput[0] += 1;]]>
                          </Expression>
                        </ZExpression>
                      </OnPressed>
                    </KeyPress>
                    <KeyPress Comment="Left" Keys="&lt;">
                      <OnPressed>
                        <ZExpression>
                          <Expression>
<![CDATA[//

kbInput[0] -= 1;]]>
                          </Expression>
                        </ZExpression>
                      </OnPressed>
                    </KeyPress>
                    <KeyPress Comment="Up" Keys="^">
                      <OnPressed>
                        <ZExpression>
                          <Expression>
<![CDATA[//

kbInput[1] += 1;]]>
                          </Expression>
                        </ZExpression>
                      </OnPressed>
                    </KeyPress>
                    <KeyPress Comment="Down" Keys="_">
                      <OnPressed>
                        <ZExpression>
                          <Expression>
<![CDATA[//

kbInput[1] -= 1;]]>
                          </Expression>
                        </ZExpression>
                      </OnPressed>
                    </KeyPress>
                  </Children>
                </Group>
              </Children>
            </Group>
          </OnUpdate>
          <OnRender>
            <Group Comment="Bounds">
              <Children>
                <UseMaterial Material="DefaultMaterial"/>
                <RenderTransformGroup Scale="8 8 1" Translate="3.5 3.5 0">
                  <Children>
                    <RenderSprite/>
                  </Children>
                </RenderTransformGroup>
              </Children>
            </Group>
          </OnRender>
          <Definitions>
            <Array Name="kbInput" Type="1" SizeDim1="2"/>
            <Array Name="Culling" Type="1" Dimensions="1" SizeDim1="2" SizeDim2="2"/>
            <Model Name="MyCamera" Position="3.4044 0.7244 0" Rotation="0 0 0.4432">
              <OnRender>
                <UseMaterial Material="DefaultMaterial"/>
                <RenderNet>
                  <RenderVertexExpression>
<![CDATA[//

if(this.Vertex.Y < 0)
{
  this.Vertex = 0;
}
else
{
  this.Vertex.X *= 2;
  this.Vertex.Y *= 4;
}]]>
                  </RenderVertexExpression>
                </RenderNet>
              </OnRender>
              <OnUpdate>
                <ZExpression>
                  <Expression>
<![CDATA[//

CurrentModel.Rotation.Z += kbInput[0]*App.DeltaTime*-1;

//

if(CurrentModel.Rotation.Z < 0)CurrentModel.Rotation.Z += 1;
if(CurrentModel.Rotation.Z > 1)CurrentModel.Rotation.Z -= 1;

//

float Angle = 0.125;

//

float Index = CurrentModel.Rotation.Z;

Culling[0,0] = 0;
Culling[1,0] = 0;
Culling[0,1] = 0;
Culling[1,1] = 0;

if(Index >= 0          && Index < 0.25+Angle)Culling[0,0] = 1;
if(Index >= 0.25-Angle && Index < 0.5 +Angle)Culling[0,1] = 1;
if(Index >= 0.5 -Angle && Index < 0.75+Angle)Culling[1,1] = 1;
if(Index >= 0.75-Angle && Index < 1         )Culling[1,0] = 1;

if(Index >= 1   -Angle && Index < 1         )Culling[0,0] = 1;
if(Index >= 0          && Index < Angle     )Culling[1,0] = 1;

//

CurrentModel.Velocity.X = sin(CurrentModel.Rotation.Z*Pi*2)*kbInput[1]*-1;
CurrentModel.Velocity.Y = cos(CurrentModel.Rotation.Z*Pi*2)*kbInput[1];

//

App.CameraPosition.X = CurrentModel.Position.X;
App.CameraPosition.Y = CurrentModel.Position.Y;]]>
                  </Expression>
                </ZExpression>
              </OnUpdate>
            </Model>
            <Model Name="Building">
              <OnRender>
                <Condition>
                  <Expression>
<![CDATA[//

int   U, V;
float X, Y;

//

X = CurrentModel.Position.X-MyCamera.Position.X;
Y = CurrentModel.Position.Y-MyCamera.Position.Y;

//

if(X < 0)U = 0; else U = 1;
if(Y > 0)V = 0; else V = 1;

//

if(abs(X) < 1 && abs(Y) < 1)return 1;
else return Culling[U,V];]]>
                  </Expression>
                  <OnTrue>
                    <RenderSprite/>
                  </OnTrue>
                </Condition>
              </OnRender>
            </Model>
            <Material Name="DefaultMaterial" WireframeWidth="1" Shading="2" Light="0"/>
          </Definitions>
        </AppState>
        <AppState Comment="GLSL Fog">
          <OnStart>
            <SpawnModel Model="o_test"/>
          </OnStart>
          <OnUpdate>
            <AnimatorSimple Duration="3" AutoStart="255" Target="App CameraPosition 2" AutoReverse="255" RepeatCount="-1" FromValue="30" ToValue="130" Smooth="255"/>
          </OnUpdate>
          <Definitions>
            <Bitmap Name="b_cells">
              <Producers>
                <BitmapCells CellStyle="4" RandomSeed="46"/>
              </Producers>
            </Bitmap>
            <Shader Name="glsl_fog" Comment="this the shader codes">
              <VertexShaderSource>
<![CDATA[varying float Distance;
void main()
{
gl_TexCoord[0] = gl_MultiTexCoord0;
gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
Distance = clamp(gl_Position.z,0.0,100.0);
}]]>
              </VertexShaderSource>
              <FragmentShaderSource>
<![CDATA[varying float Distance;
uniform sampler2D TheTexture;
void main (void)
{
vec4 color= texture2D(TheTexture, gl_TexCoord[0].st);
gl_FragColor = mix(color, vec4(0,0,0,1), Distance/100.0); 
//fog color in line above; vec4(r,g,b,a)
// fog fades from camera to 100 in Z direction,. . 
}]]>
              </FragmentShaderSource>
            </Shader>
            <Material Name="m_fog" Light="0" Blend="1" Shader="glsl_fog">
              <Textures>
                <MaterialTexture Texture="b_cells"/>
              </Textures>
            </Material>
            <Mesh Name="g_box">
              <Producers>
                <MeshBox/>
              </Producers>
            </Mesh>
            <Model Name="o_test" Rotation="0 0.25 0" RotationVelocity="0 0 0.1">
              <OnRender>
                <UseMaterial Material="m_fog"/>
                <Repeat Comment="some model,. ." Count="10">
                  <OnIteration>
                    <RenderTransform Rotate="0 0 0.1"/>
                    <RenderTransformGroup Scale="10 1 1" Translate="8 0 0" Rotate="0.123 -0.25 0">
                      <Children>
                        <RenderMesh Mesh="g_box"/>
                      </Children>
                    </RenderTransformGroup>
                  </OnIteration>
                </Repeat>
              </OnRender>
            </Model>
          </Definitions>
        </AppState>
        <AppState Comment="HSV ColorExample Library Example">
          <OnStart>
            <ZLibrary Comment="HSV Library">
              <Source>
<![CDATA[//

float angle(float X)
{
  if(X >= 0 && X < 360)return X;
  if(X > 360)return X-floor(X/360)* 360;
  if(X <   0)return X+floor(X/360)*-360;
}

//

void hsv(float H, float S, float V)
{
  float R,G,B,I,F,P,Q,T;
  
  H = angle(H);
  S = clamp(S,0,100);
  V = clamp(V,0,100);

  H /= 60;
  S /= 100;
  V /= 100;
  
  if(S == 0)
  {
    ColorExample[0] = V;
    ColorExample[1] = V;
    ColorExample[2] = V;
    return;
  }

  I = floor(H);
  F = H-I;

  P = V*(1-S);
  Q = V*(1-S*F);
  T = V*(1-S*(1-F));

  if(I == 0){R = V; G = T; B = P;}
  if(I == 1){R = Q; G = V; B = P;}
  if(I == 2){R = P; G = V; B = T;}
  if(I == 3){R = P; G = Q; B = V;}
  if(I == 4){R = T; G = P; B = V;}
  if(I == 5){R = V; G = P; B = Q;}
  
  ColorExample[0] = R;
  ColorExample[1] = G;
  ColorExample[2] = B;
}]]>
              </Source>
            </ZLibrary>
          </OnStart>
          <OnRender>
            <ZExpression>
              <Expression>
<![CDATA[//

hsv(720-App.Time*90,(sin(App.Time*3)+1)*50,(cos(App.Time*7)+1)*50);

//

DebugHSV.Color.R = ColorExample[0];
DebugHSV.Color.G = ColorExample[1];
DebugHSV.Color.B = ColorExample[2];]]>
              </Expression>
            </ZExpression>
            <UseMaterial Material="DefaultMaterialHSV"/>
            <RenderSetColor Name="DebugHSV" Color="1 0.5 0.5 0"/>
            <RenderSprite/>
          </OnRender>
          <Definitions>
            <Array Name="ColorExample" SizeDim1="3"/>
            <Material Name="DefaultMaterialHSV" Shading="1" Light="0" ZBuffer="0"/>
          </Definitions>
        </AppState>
        <AppState Comment="MatrixExample Library Example">
          <OnStart>
            <ZLibrary Comment="MatrixExample Library">
              <Source>
<![CDATA[//

void RotationMatrixX(int K, float Angle)
{
  float C, S;

  C = cos(Angle);
  S = sin(Angle);

  MatrixExample[K,0,0] = 1;
  MatrixExample[K,0,1] = 0;
  MatrixExample[K,0,2] = 0;

  MatrixExample[K,1,0] = 0;
  MatrixExample[K,1,1] = C;
  MatrixExample[K,1,2] = S*-1;

  MatrixExample[K,2,0] = 0;
  MatrixExample[K,2,1] = S;
  MatrixExample[K,2,2] = C;
}

void RotationMatrixY(int K, float Angle)
{
  float C, S;

  C = cos(Angle);
  S = sin(Angle);

  MatrixExample[K,0,0] = C;
  MatrixExample[K,0,1] = 0;
  MatrixExample[K,0,2] = S;

  MatrixExample[K,1,0] = 0;
  MatrixExample[K,1,1] = 1;
  MatrixExample[K,1,2] = 0;

  MatrixExample[K,2,0] = S*-1;
  MatrixExample[K,2,1] = 0;
  MatrixExample[K,2,2] = C;
}

void RotationMatrixZ(int K, float Angle)
{
  float C, S;
  
  C = cos(Angle);
  S = sin(Angle);
  
  MatrixExample[K,0,0] = C;
  MatrixExample[K,0,1] = S*-1;
  MatrixExample[K,0,2] = 0;
  
  MatrixExample[K,1,0] = S;
  MatrixExample[K,1,1] = C;
  MatrixExample[K,1,2] = 0;
  
  MatrixExample[K,2,0] = 0;
  MatrixExample[K,2,1] = 0;
  MatrixExample[K,2,2] = 1;
}

//

void MultiplyMatrix(int K, int A, int B)
{
  MatrixExample[K,0,0] = MatrixExample[A,0,0]*MatrixExample[B,0,0]+MatrixExample[A,0,1]*MatrixExample[B,1,0]+MatrixExample[A,0,2]*MatrixExample[B,2,0];
  MatrixExample[K,0,1] = MatrixExample[A,0,0]*MatrixExample[B,0,1]+MatrixExample[A,0,1]*MatrixExample[B,1,1]+MatrixExample[A,0,2]*MatrixExample[B,2,1];
  MatrixExample[K,0,2] = MatrixExample[A,0,0]*MatrixExample[B,0,2]+MatrixExample[A,0,1]*MatrixExample[B,1,2]+MatrixExample[A,0,2]*MatrixExample[B,2,2];
  
  MatrixExample[K,1,0] = MatrixExample[A,1,0]*MatrixExample[B,0,0]+MatrixExample[A,1,1]*MatrixExample[B,1,0]+MatrixExample[A,1,2]*MatrixExample[B,2,0];
  MatrixExample[K,1,1] = MatrixExample[A,1,0]*MatrixExample[B,0,1]+MatrixExample[A,1,1]*MatrixExample[B,1,1]+MatrixExample[A,1,2]*MatrixExample[B,2,1];
  MatrixExample[K,1,2] = MatrixExample[A,1,0]*MatrixExample[B,0,2]+MatrixExample[A,1,1]*MatrixExample[B,1,2]+MatrixExample[A,1,2]*MatrixExample[B,2,2];

  MatrixExample[K,2,0] = MatrixExample[A,2,0]*MatrixExample[B,0,0]+MatrixExample[A,2,1]*MatrixExample[B,1,0]+MatrixExample[A,2,2]*MatrixExample[B,2,0];
  MatrixExample[K,2,1] = MatrixExample[A,2,0]*MatrixExample[B,0,1]+MatrixExample[A,2,1]*MatrixExample[B,1,1]+MatrixExample[A,2,2]*MatrixExample[B,2,1];
  MatrixExample[K,2,2] = MatrixExample[A,2,0]*MatrixExample[B,0,2]+MatrixExample[A,2,1]*MatrixExample[B,1,2]+MatrixExample[A,2,2]*MatrixExample[B,2,2];
}

//

void Rotate(float VX, float VY, float VZ, float AX, float AY, float AZ)
{
  RotationMatrixX(1,AX);
  RotationMatrixY(2,AY);
  RotationMatrixZ(3,AZ);
  
  MultiplyMatrix(4,1,2);
  MultiplyMatrix(5,4,3);
  
  MatrixExample[0,0,0] = VX*MatrixExample[5,0,0]+VY*MatrixExample[5,0,1]+VZ*MatrixExample[5,0,2];
  MatrixExample[0,1,0] = VX*MatrixExample[5,1,0]+VY*MatrixExample[5,1,1]+VZ*MatrixExample[5,1,2];
  MatrixExample[0,2,0] = VX*MatrixExample[5,2,0]+VY*MatrixExample[5,2,1]+VZ*MatrixExample[5,2,2];
}]]>
              </Source>
            </ZLibrary>
          </OnStart>
          <OnUpdate>
            <ZExpression>
              <Expression>
<![CDATA[//

Sprite.Rotate.X = App.Time/4;
Sprite.Rotate.Y = App.Time/4;
Sprite.Rotate.Z = App.Time/4;

//

Rotate(0.5,0.5,0,Sprite.Rotate.X*Pi*2,Sprite.Rotate.Y*Pi*2, Sprite.Rotate.Z*Pi*2);

//

Debug.Translate.X = MatrixExample[0,0,0];
Debug.Translate.Y = MatrixExample[0,1,0];
Debug.Translate.Z = MatrixExample[0,2,0];]]>
              </Expression>
            </ZExpression>
          </OnUpdate>
          <OnRender>
            <UseMaterial Material="MatrixMaterial"/>
            <RenderTransformGroup Name="Sprite">
              <Children>
                <RenderSetColor Color="1 1 1 1"/>
                <RenderSprite/>
              </Children>
            </RenderTransformGroup>
            <RenderTransformGroup Name="Debug" Scale="0.25 0.25 1" Translate="0.5 0.5 0">
              <Children>
                <RenderSetColor Color="1 0 0.502 1"/>
                <RenderSprite/>
              </Children>
            </RenderTransformGroup>
          </OnRender>
          <Definitions>
            <Array Name="MatrixExample" Dimensions="2" SizeDim1="6" SizeDim2="3" SizeDim3="3"/>
            <Material Name="MatrixMaterial" WireframeWidth="1" Shading="2" Light="0" DrawBackFace="255"/>
          </Definitions>
        </AppState>
        <AppState Comment="Proportional Type">
          <OnRender>
            <Group Comment="Text">
              <Children>
                <UseMaterial Material="ArialMaterial"/>
                <RenderText TextArray="String" X="-1.175" Align="1" UseModelSpace="255">
                  <RenderCharExpression>
<![CDATA[//

if(CharI != 0)
{
  float L = Letter[String[CharI-1]];
  CharX -= 1-L;
}]]>
                  </RenderCharExpression>
                </RenderText>
              </Children>
            </Group>
          </OnRender>
          <Definitions>
            <Group Comment="Arial">
              <Children>
                <Font Name="Arial" Bitmap="ArialBitmap" FirstChar="32" CharPixelWidth="24" CharPixelHeight="24"/>
                <Bitmap Name="ArialBitmap" Width="4" Height="4">
                  <Producers>
                    <BitmapFromFile Transparency="2" HasAlphaLayer="1">
                      <BitmapFile>
<![CDATA[78DAED5D4D96A33AACAE2D863D244B6007F4069205F0E6C53C8C611CA6C93419C2344CFD6E9D875FABDC3618901C7E3ECEF9CEBD5D5D6D8CADCF966449564A7D29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080E9D00FC6020096894290A792FCD7CF0D73088CC4F93FB49DFCD4FFE1B8D37128D5EF678DFC57DD7740AEB78587202FCF86FCD43B1D63BD06262BD5FF13D8189B45FA1FEE013910C13E5FA5FD0FFE6F5B3EA5DF7113DE03E7EAB6AE07FC5F37FF43CCAF46D4D9480D69FF47BF8E27B69709F737E4BCEA6FC9C07FF07F217B1BE7F79C05E4E8DBE0CB9AF91F77EFB9ABE5D9E525F47FF09FC93F521AFEB4D37FA816CCFFD073D12EA83F47B2061482EFF8795E2BE7E6BB7BC711FC77EE2367019D794BFC6F16E8033C91F99338E3BE05B07B42F0FFBAD2380069FE6BBDBF12E8FB7787ADF07F893E40530F7809F0F2BA11DD3C1778D7D971265533D966D2FCAF04657A6BFBFF127D8014AFAE7F4F263D776BFCBF0ABC8BEACD319903FA540BE57F33E0F36BC07FAB0FF0B1E03EBE889F82630DD0B17FF9CAF99F0BF94AEF0EDEC44417500BDEFF25C77E6BFCD7DFF05E781FE91A30D7577108E0F70CC17FC9F8AD82F0DEA61B5E56BAFFCFD501B6C87F3D668795C4001C57C04F9CFF7D6EFFBFC3FE9FC5B3FBC2F98FF37FF07F287E1EFEFF6976DE5E62CAC1FF7D9CFF5FB0FF6FC20728C59DB5E6FFC588FFEFC585B457743125F46CF936D16FB245FED33939ED84FF8F15E770D0073540FC6A5DD89EC344FED79DEE7CDF10FF6DB640BC71F9A856CE7F70DF2FFF2F336218EE33F6B9A8E305C516F970DF01FF0100000000000000000000000000D85E6CCE16636A00C017F5406E07F80F1901B6BFBFD2F828F01FFC07F68558C9DF8301FE03C072A1EBFFD40BE5FF83F42F13F8F6C6C87DE0E07F883524517F6BB72992EF1633B5AD6D44A91A09A9F18E5268ECB47C9F05BE21EADA366B49E533E2671B629B9B7F570AE435460B8CFDD7CFD362AB70E5289596B69F2BE17F32903F335797AB495B12FCFF76F45BE23ED6B7E0FEA66BAF99F52975AC71395127579635EB28341F344F2A5D18FF5BB286C6642EE7E6749E1DEDB72BE17FEDE079CA24EBFA91AA2BDE58F891308EBF4DB639E4C69563AC7AFC6B73749646C9D734A917984FE2DAC7CE4CFD7C38E4215909FFA5DF2DDD7FFD98F9B77F98DFDD907976E9D473F790D290D50BD1D1E7ECA90FA20348D5338989FEB224BF575F5FA4E57B6DFC8FBBFDE2AE7EDFEBBED6DA285CEFBE189C2966D8E4363CBBF52432CED00AB2B6D533E622EAE6B3E9FE2B61BF14647DBC338F0FF82FEFB7B5E5B6B70C7E9C2DF0DF94676D3F73D4B6D36DE5C65AA0758E9AC10F48ED3909FF6564F81332872F13FC5F1E7F7283EF45272BB15A8E0DF1C9F177DD6BF960DAE30AC33F42794ED785E3CCF89A57B79E348AFFAEBACCE8EBC9E1CBFC24FF2F0E9B6BEE1AFE70ACA96766FE4BD7164BD5727D089FE4BFCB57C655E74E9F157D59740B737D79397C1DBE6B7C4AF400CEBD59FBFD0E167FE652FDFF2D93DCA781FCFF4F25539BDF350E29939F6BCDFC3F0E8C413D918FE618A78E39691DBF9F4DD05FDA8E9F11699F43C73B3BD6C14AE89C64AA7CE416FB964B3FB1DD699533F3FF2114633D74AFFD85A1EF4A701D90E47F31602F5F669CCDD33305573C49E9F8A67AC2DE7C769C597F31E9BFAEF3B5422DC7FED7E3FA56FCF75C95645DCD05ECFFC8125FC81903743774A58AC1E6583BFF7DB8364707709D3F273DEB8E8ED3FCE3D1FEADE7ACEFC6700E18F5E8478705C60203C881000000FC0700401E6FF01F00769F178A7100000000000000000000000000000000D6E8DFA6F5BE6AB5BC3AC89F3AFB7F2AB9DA3F00F069E43DB1F32DF83F3BC61400D620E3A911177D9F991BB2059C10FF07EC7C6D78610CC07F60F33248F3FF5E2A4CFD4FE9F6D75CFF2367CA95FC54FFC7FEFC53F243F37D691EFC53C9DC93B0C4397CAAFE07FC0FDB3EAD7B1F81FFE2FC2F7A64BFDC38FF750D88B7B2DF2F00FE876F5FEF43F98AF597B5F0FF427CDDD40796127DF8B261FEBBEAFF9FC1FF8FB49F319FBD80FF7EF29F5AFE2E65B2C1963C879FE427F8FFF739ABDFF7CF65E0FF22E46709FE5FF07FFBFCD771573F4FA3D66DBF80FFE03FF83FAE7D7A076B02FE83FF81FA700F64FF9B321D81FFFFB4AFFDD0C50AFB9F387E7E64E2BF94FCDC3DECFFFB86F91FEAFEDFD698C38229BE686BFEBF92F9DC2954FFE9FD0ED9C0CF5B06F929996C252AFF6783FB6FE29BF924EF39CFE36DB0D5FFAF98F95F39BE2503FFFF699F730D08D57F5B1EC9D9215BC584F61B21F9F9326CAF397D5D2BFFCDF8BF52C8BEA2F774368AE7CEAEADC6FF954C7B4FC8FEE7642FCD1DFC2AD43CFBE84DE487B32EE365C7F17FE8FB76C707E3BF1D193942BEC17F8CFFEEF030F4FF07E41BED83FFBB4164F8CFEEE03FDA07FF010000000000000000000000000000801131866BEEFBD083F90600F01F00009C13030000FE03C01A62007F9E1AFCDF1CAE242FF2E7BF37F57FB9EE3143BCB7993F67CBCFE340A6FED62F6B157FDD6C3A468580CC9AB9CA4DF70DD1426444D72229C1FF4D21F7F05B240CF37AB3B4CB1547FE72F49BEBEEA8BBA5ED1BA3CCF6E5FFFFAC39A705C8C98D4116C0FFE5DA5DA9B11749D45FB2D5779A9BE36EBB3FE267CF7C1A7BF59C7DB9AFFF8AB1FFFF63E8DBF982F26D5AE489ECCAEF1233F33F71C8FDDC5CD287631D89086F39F67EB3FD3F4CE3D357FF7F29D0F7D03EC1FFCDA1247E9D9FFFFFEEB87A60E6BFD49C7F327F710DFDE7C077D7C71CFCDF246E82710BE03F4F0CC912EA7FC4E0FFA6CF77D24EDF7DA8DFF52EC1FF7DF33F441F24DEA1FDC2B46ED931802D83988C7FDBB838ECFFB9BEADFB80FD5F33B5EFF25F2826DDEBD073E6FE49FF5F12A80F12FCD7679657CB79570A7E3BFDFF749CDEC2FEFFB9F340FDF309E1CD8BC9FF9F0AFBFF1372569918FED717D31909C7F970BA521D43C752E83FD7B033BCCF9E397C3EF4AC5FEA7CFED573762ED5FE9D51668B9EF12F3F2C1FFADB4F2BE57F45FA7F24B11BE0FEEFBDE666EC695CF5ED5DF17FDC729D193CBD31C7CE154AE67E0AAAC73C8DB5F1BC10FDB055EBF53124641FCB856398807DF975B7EEB3BE04DC2F25C7B2EDF6B326D05A26B18635E008BE2D308A00FE8710E71C57467BF653B1973938826F0B0C7D061CAD9CFF27D2FE69657350ADB4DFE03F00000000000000000000000000000000007B8F8FC259020080FF181300407C340000E0FF5AFAD8CCCC573C74F1C666AEE54DFD5B3B6289E31D75DFDE18F9A795E2AB9B7434C6E624A88BFAFE5E5F6C684972D986DEFD64CC77E59AE35A8D7BF6CA7F5A23614AACF0C5636C1F0BE6FFD9A3FF1C6BD8D568933327C09C8364209F5279E686F8EC0B3ACFA459D81CE7E0BF571F755EF4947C715A67DAB6579E890C650BE4FFC9E0E3C9D8AFBFC9DFCFD5031AC2394EBED0BDFA31B0B6E835E8EEB95F1F07D68A8B803EC335C75127DBAD82FEAF06D6C8A963547970FB34F31D92E3AD7973F5D8DF2A06DDBF3674D32373AE576CBC67E8F77CE6C4A51FFEFCFFBBFBBB74A19C8A47D8307BE33F5DDBD3996D4781C6897BBC1B0F1E0E716A8CEE9F3BFECCA1C3D4862D1E597C34940BCD8835A8B2F0E8C5B02E869863BD7E15E0FF2FBC986DF3106B30F778FBB637F7BDB5A1231F19D61453BE4B43A74B1D7E8EEBC0EFB940F7FA9451A70BC1A992D18FB305FEEBF993AAA37DE8C6BAF0F0496D9DFF4787BDCF650398773B26E4ECC5C601F3F7AA91EBF89DF80F6201B9F1D529C7E2C96C73AD8DFFB6479F7171F86E924EC65ACB3B92858E7708FEE70E5D9FCB06B0F5CDB637B78EDF1BF35D19F9379980ACD2F363EEBD49C21FB876FEEBE73D735D34EB43DF3BF98817AE6F85E0BF6B9F3F31D8002EDBCADC9F4F0E5B6FECDD5031E379886B6DB99235937B8D8999D796B5FBFF4F4406A6D6092D880C261FFC9625F2FF3870D637D706D09CF9367EFE6DF02775D8FAD9489EB55D9FB9F7D1A345676905F4756E7FE056E2FFD61203B136FE0FE9F8F94C1BE0E9D88BCD7BD21E0E2E8DD90F2B12079032FBFE5F9671F816F45171F903C1FF617FCD61C1E7FFD2FC6F06626386F4039F7EB503FEFA31BF37B467DACEFFE69EFDE73D3C7F0AC44A9AFD3FEE98FF1159D7AB996BA94DFF4F14DF5D6E6BE3BFEF19DFD01AF13510CB7B1BD8AFCB81F1AF06CE678E8E183F1A3B399543F1401B47417FC3A15B13DF0AFEBFB9E3FB1A68FB29D8EF10B6CB9477F8EAF653CF01CA81FDD7CC6BB84CB487EB1E1FC1F74CFDC527363C9DE127F57D72266EAD91FF77A6B5F5DBB20E3C18620BD7CA7FDFF8BAA936403D607745C6F84403F1834DCF1AF3F458FBC7E6FE5523E2CFEE137554DFA7DE30FF0100000000000000000000000000000000000000000000000000E0C159C9D421FB647EBB74EC5362C41572D6E4F7ED7F3D31C6CD37068DBBEF2F4BBECE94F9F2F9DD8C49060E5D1C6E63C4E55DD5BC5A40A162F3A28EDB66FF8B2EF6BA21F1B6E0FFF8FC10CE7C8531FDBFCDC861F804FF87E27E39F9AF6BEACCFD0E9F3B18D205F3FFE239CF59607D63EDFCB7E526EA98F45B8031D27B5BABA6E7B8498E8FADED94EC3336DE70F2FFC1B08E51EE94C6381FC97C4F5D03A4F97F36FA7FB2E48069193A81FF93DA3E29997A027DFD4F18F69E4FF0FF45F67D9BDEC2C57FBDCE5C677C23D555CE1E1C9B724795E4F853FDE7E2C859BA93B16AC0FF517838DAE67CA7ADAD1399D72AD01C70B41D197DD6B6CB8199FF5AEEEB99DFA8F7471F9F98D603F2058D7FD6E3178A0D1BB5F458E7C0FFF0EF5496F5FB49FC375F2BE27F6A7CCBC5A2BF70F0BF327C3053BFF135C297A37D418F05EE4F92FD07FFC3F05FF3E6E6B03BD6C0FF97E55DA60D3097FFB67B03A67EE3D87F37E53D7DCF53F5DFFDB684FE87A8FD03FEF3F99B3FC5FFC861AF54C639C05CFEDB6AFFAE95FF6AA62F09FCDF96FEAF986CFE4FF03F75D89767633D9BC37F57ADC035F07F28B6A4D830FFA1FFFBB595339CF77D8AFF3F72ECAA65D9121B602AFFFBEE0B9BFA8D63EE114B26C6CF0CF5ED34C3373FA5FF4FF07FB1FCA73E9D6645FC8F06F6B0C2F8BD29FC6F7ACEDF42FAFF3381F19FDAFF2CC0F905F81FFEFCEFD9133FBB44FEA70EBDDCDC7BD289FC1FBA2B78EA371E3CCFFF2F82E7FF73E249E8F9BF4FFF95E2BFD714FC973DFFBFAF80FF2F0FF96DC9BA3696FF43E75673BEB12F7ECE8CFF3B338FFF918CC9D4BC9CB4277EF164F4FF1BF13FABE0BF997B502C9CFFAE18149BFE3985FFAD1143C4FD8DA9876FFAC230467DFEFF48B8FFA163FFC17FBE18571F7E7D627C5AF5F7AEE5217FE5A9FBBDFB085DD7F72C94E31BA36E8C69FE5CD3ADBD11D31A693E4DF74E0E9D5CAAFF0000000000000000000000000000007BC1CFB9DC95F8B1CD33EA5C85AFB30200803CEF1BE5FFDC316600B0099C8D588DB28B693D58D6889FB3EA5A208F070080F0F833310627638AED0200E073B16EAD1183FBB39FDF08B73383EFAAFBFB98E45DD862D7DF23E2E05AE5CEAD9D137FF662CC078BBBEF6E8DF633A63975D95867C1F6D58498E54FC6A7A616BF949EE323F83F1A9ABFB525DFCAE491EDE9934D9D139B28BFBCED4250BEE7D6322E3DE25C8F82FD7FEE9CFF89432ECDA70ACCC7BBE2BD2B27342A23F7A3207C8F886FC0BC8382FEECDCB35FFAF05A732B1690BF58CDCF3FCB0D5D28326CA7C6584339FBCF71AF8D343FA5DB3F1BE74F89656D2819D7FA29DFBED675E0DDF53F326C01D39E3F92BF3B19FCEE1BEF5AF9E5CD3682F2779C2117B49E47DFFEDECCC841F3E14F3B638D5C3BFF5DF5FFFB6A1D843C332B03AE03DCDF67B6D7D77E66C9552B06E43E1FB001B4EE2F5D2376EAB8E59E7ED164860EE0D3B76C827F760BFC4F89BF69A9B9B27A9FC8C85AF5105A0774FB07A1B973EDFF742F2C2C3ABEAB8ECFC9D3EE3C0ACADF501FFB30A6FEFC79E2BCF8C86C3CC30FB066FE3F3C7D489FE67F9FCDC6B90E94336D5997DE7A30FC0169CFF8D623C7BCF6F09D49D6176847CA506879F27DC7D4BEAC99FF7D6D73FB31B99109F4E740E4B96468EF66F8F0FA6C7A6A0B4723E63F75AC59E5C05AC3E5DF7E09F916D7C67F25C499106DAF89FF92FBBFD6A96BA635E06C39BFAF2CBC898C33C08BA1DFD71E3EB456C896197A72B55CDF16F8BF7C7DDED7FEFF0E60FF533C67F89C877CCBAEF3FEC258777CFD522F43074F66D8E4BE327250D36B5A9BFDFEB44FF708FB7FB13933C587CE0123A6F3CE94B47334EC9786D8E80999EF86C8A40F3F4C1BA060D2FD7DE46FCE18F9FAFFA34E56A5CEFFC6D4C1DFA2FFDF27F641C7AD865C2B54207FFF71C01EE78863D23CF1BD6B75ECFDDD94872DA3CCF8F07FEABB0E9E671495303F71FE3F1C075D31E9C363F513C9FDBE247A72629C37BF2CB63B873DA1DBBC187EBEA87BEFC3F0AD8D8D352C9963355DF2179177CDC955A67EDC6F631D3892EF1AAAE13D853F09F1F53C16CACF90F17F3747FCDFE303B17FA1F0EAF1ABB48AB716C7F7087FD158BFDAC5F8F71766F9938A2F30D700DBF39E310F3ECF4B787CE67058DABFA8656728FE7FCBB9E8DFC6FEDC28D97BCED26E4DB5D5FFC9D4F47CDF56609DEE93871BA34C687DE269F05232FFEF11E07C740DFCD7B658466C55EA73CB36CA7B00000000000000000000000000000000000000B0C5A8611C00609F4855F8BA9800002C070A63107CBC39C73C53BFEBE83C98F39C746D7B1A5F982D783C6C797AB5118F5B32C5FEE9B83F1ABB582AB91A6C6B8BCF0764C7FCD91353C95107EC22DCFE97FA9B472C119FFD1C88018E6672FF2D9C7B01FE83FF2E1464BFA7FBCD89C87D3253BEB52C27465E9BCE3B3A337C87CE91FBC33CCE25C90B8B1DE35330B4FF24E31FA9BFF71F3490F541BDF20EFECFCE7DB6E99ABA864E35536F565D7E91AB7D8EF94B27E60CFA8E8F547D94BE7AC839E3FAB845DE3F76A07B84CA7D925A67EE03FF9E33774B09EC972A50FFBF7AD6C71BF8FECF7E4FEDC778C5FCDA3AFF43F2E729E003A87BF667BDFF73D418A4773BD4C437AA6D03F0FEEF7EFFEEF4C9C306F8E56B1FA61FF0B91C893CCE1DDFB3634EE7B66FF33316027BF0CBF0C551FFC5DC7392A15AA80ABCFF7F39B9EC700CB47C9C04F8DF38FC6654BE3306FEBF8DB9E36ADFF53D07E635C076C7C84BCDAFCD9691B6A8DE62BB1375CF7EEE3DD7DFD077663F05FDFFAEE7C5347F8550FB2E1DA0646EF76A39A7CB19D72BDB3A7206FFFFD9FFF7EA0B4D0CB9E6928B0B39FFA3F5B86BA635F745FA49DB6F955C7DB1478FCDCE7586A1F7EDAB92F5AF70CCF316CEFFE93A60BB277DABF63FC537B1A5B9FDE652754D2B261B798ADF82EB5CD87506C8316E3EFCBF83FFCE73BF72E3FE7FDB791AB75D28193B77E991E14870EDC91C7E534EF9E698833E1F62C2A463E0FC7F5B6898BF9BF3AE9CBE33B4D4E1FF2B84DE6BF39BCEB1276CFAFFDCBDF9EC111F1981EF83EBC09EBEF9C4CCFF8BB0EE7352EEDAEA5CFA73DFF3669031D773625C7F6D0F62FF80BE7D83EB7C41DAF63974726EE6B8ADC57F63EA9B95E2BD172533F4BA4A85BBE71100000000000000000000000000000000000000C6C62C621C00609F4815EAC303C09EA1300600B0EB1A0EE8BF7CAD923E1DEC41E22FB9EF5F901AAF50F19DE6FD172FC45E83FFC2FD2F85F3AEA8FFC5F53C163E5E5500FEBF7ADA2DC05540081CF5D57D6B21B4EA77FDB50BD105E205CB90AE7DD52A99FCF46BD7D7A7A187C5EA6F3DD90CFC0704C7BB156C3FEF91615D4F265FB80C9DC81AC05D47A6EFFE8598D84AE03F2059A3E028ACFBC73DF27D5F890C551FD88FF7C687357DAF942F2824AEC232DD0E8C8984FE21390F5A9F2903CC4D14403F5B2A87D6C0A92DF05F6A0FF6E5A2C49849CFC325C01A705032F5E9C17F20245FB6C87FBA0614CC6BF153FDAEF39243168140E77309F83F0A378171530BE37E6EE8860F255B0F16FCFF4C7CB4129AD77700FBFFF221193A92581DCE764F0B3AFB3B135B47C78B5CC0FF4DE144CEA043FAFFBF987C0FFA8CECF2011992B69DDE1F948BA89BB71BF9CE9F33903F4AAE2634F8FF19B442E37EED89313C33ED71F4EEE28A5986FAC62566D05FFAEE77FE34179E645FA83BBC84741EE0B3B809E976B123FE8FDE2FCA55C7B812F0199744DE8F46EC64CB700E90118E9D88EFBF123E97F1D50B23B24E3D895E7004673685B360BC79C8F8FF5460DFEC8BCF7F31EEB3E6D32E8867D0CBB70D7D0F632DD4BE79BFC053FDBECF4822AF89BBFF741DA899FDA5B9FA7D376DA170EF120000000000000000000000000000000084C045F1D74AAA84E3690100E08B91E6AE95AACF5D114F03F8C661601CC2E3A5E4F2FD4BC4D302E0FFE26323A5F6E86380BC3AE4FCCBE6CD4423725EA7C84749DED5767FE68E0F8B07625ACF2446AD5132F5029688462837D2D42F1AF07F75D0B55A921139AF637330DB9EF870A9D859F3EE89C4C875292CDFBD45E8EFBE0ABF27DFC9786E0D9925873563CA6BA5396D0FF5B71E644462D1B96D525AEFDE96A31291DFDB431E68A8752E119A4F20CCBCDD2D3FBB09D817CAE09F840EF06D59BF6C3ADA1E72C29E427E7FDBBABB87F5744BFAFFD887DBFF27396EE6DD807BE57FC86FDC6B8E2DF83F9DFF523E235DDFB652BF73E00F3BDBAFC07F7CB7AF8D7EB2F8004F026375547FEBF57C0B7E17F563BAFC7F7F209BE0C1CEBF5BFBFBD2819FCDB50F73439FB833EEF5B673BD93A163FC7C4BBDB3F3BF97E57C17F63FF8FF35E0EFE3F4015E0DDE3F18F75D735F2F0D7F77A83BC297EEFF8F85DFA3632F0AF01FF6BFE55CB8253A85C4FE66DAF54FE30CA2DD29FF13C6B35C1F1D3201FFD9E3594AE3CFC58AF8DF1AB1A72AC0D89B3F93BAA79B6B7F963E33AF03E8E588FF93F36199F71749D454AE7AE200FF308E0DF7F9BFEFB95E13C80E9E3BBF124885BF3DDAB98D25C97F15E8CC5C2A0EF045EC421AFFF7648A1733E35B0E0E3F54C2EC735C9BED2899FF5704C82F00FF65DF1513DF1C2767E21E7B82C3264F0CBF535FBCEB23902F6C89FC3F09E9009161DF81FFEBE4FF97859307269EEAF37E33FFEFC0A8DF6AFDBEEEF1419DC8EFECD1777C56FCF795DC15EAFF00C8FF070000001680FF05605FF452]]>
                      </BitmapFile>
                    </BitmapFromFile>
                  </Producers>
                </Bitmap>
                <Material Name="ArialMaterial" Shading="1" Light="0" Blend="1" ZBuffer="0" Font="Arial"/>
                <Array Name="Letter" SizeDim1="128" Persistent="255">
                  <Values>
<![CDATA[78DA6360185870F6CC193BF2F4F9D851CB0DB3664ADA0F703080ED4F4B7B660765037103980D12333636B643F7B7B1F167B83C44BCC70E22D600536B0FD4876C2E560000B8961A6B]]>
                  </Values>
                </Array>
              </Children>
            </Group>
            <Group Comment="String">
              <Children>
                <Array Name="String" Type="1" SizeDim1="64" Persistent="255">
                  <Values>
<![CDATA[78DA758DED0980300C44334A27700747113F6A41ACD4A2B8BD577801FF587890EBE52EBD99057188223273465791D0BB18C446A6790FFBB358F0477460F66CC54FE8939D48A777AD1F2FD3DBE68B7C61D77B22FECDDFC42DEFE9ECFFBD563C1628]]>
                  </Values>
                </Array>
              </Children>
            </Group>
          </Definitions>
        </AppState>
        <AppState Comment="Input">
          <OnStart>
            <ZExpression>
              <Expression>
<![CDATA[App.CameraPosition.X = 4;
App.CameraPosition.Y = -1.5;
App.CameraPosition.Z = 10;]]>
              </Expression>
            </ZExpression>
          </OnStart>
          <OnUpdate>
            <Group Comment="Input">
              <Children>
                <ZExpression Comment="Reset">
                  <Expression>
<![CDATA[for(int U=0; U<Input.SizeDim1; ++U)
{
  for(int V=0; V<Input.SizeDim2; ++V)
  {
    Input[U,V,Input.SizeDim3-1] = Input[U,V,0];
    for(int W=0; W<Input.SizeDim3-1; ++W)
    {
       Input[U,V,W] = 0;
    }
  }
}]]>
                  </Expression>
                </ZExpression>
                <Group Comment="Keys">
                  <Children>
                    <Group Comment="P1">
                      <Children>
                        <KeyPress Comment="Right" Keys="&gt;">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[0,0,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                        <KeyPress Comment="Left" Keys="&lt;">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[0,1,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                        <KeyPress Comment="Up" Keys="^">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[0,2,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                        <KeyPress Comment="Down" Keys="_">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[0,3,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                      </Children>
                    </Group>
                    <Group Comment="P2">
                      <Children>
                        <KeyPress Comment="Right" Keys="D">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[1,0,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                        <KeyPress Comment="Left" Keys="A">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[1,1,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                        <KeyPress Comment="Up" Keys="W">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[1,2,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                        <KeyPress Comment="Down" Keys="S">
                          <OnPressed>
                            <ZExpression>
                              <Expression>
<![CDATA[//

Input[1,3,0] = 1;]]>
                              </Expression>
                            </ZExpression>
                          </OnPressed>
                        </KeyPress>
                      </Children>
                    </Group>
                  </Children>
                </Group>
                <ZExpression Comment="Events">
                  <Expression>
<![CDATA[// the Events are:
// [x, x, 0 ] : Key Down
// [x, x, 1 ] : Key Pressed (in this frame)
// [x, x, 2 ] : Key Released (in this frame)

for(int U=0; U<Input.SizeDim1; ++U)
{
  for(int V=0; V<Input.SizeDim2; ++V)
  {
    if(Input[U,V,0] == 1 && Input[U,V,Input.SizeDim3-1] == 0){Input[U,V,1] = 1;}
    if(Input[U,V,0] == 0 && Input[U,V,Input.SizeDim3-1] == 1){Input[U,V,2] = 1;}
  }
}]]>
                  </Expression>
                </ZExpression>
              </Children>
            </Group>
          </OnUpdate>
          <OnRender>
            <Repeat Name="Slots">
              <OnIteration>
                <Repeat Name="Keys">
                  <OnIteration>
                    <Repeat Name="Events">
                      <OnIteration>
                        <ZExpression>
                          <Expression>
<![CDATA[//

int U = Slots.iteration;
int V = Keys.iteration;
int W = Events.iteration;

SpriteRTG.Translate.X = U*( Input.SizeDim2+1 )+V;
SpriteRTG.Translate.Y = W*-1;
SpriteRTG.Translate.Z = Input[U,V,W]*-1;]]>
                          </Expression>
                        </ZExpression>
                        <RenderTransformGroup Name="SpriteRTG" Scale="0.75 0.75 1" Translate="8 -3 0">
                          <Children>
                            <RenderSprite/>
                          </Children>
                        </RenderTransformGroup>
                      </OnIteration>
                      <WhileExp>
<![CDATA[//

return this.iteration < Input.SizeDim3;]]>
                      </WhileExp>
                    </Repeat>
                  </OnIteration>
                  <WhileExp>
<![CDATA[//

return this.iteration < Input.SizeDim2;]]>
                  </WhileExp>
                </Repeat>
              </OnIteration>
              <WhileExp>
<![CDATA[//

return this.iteration < Input.SizeDim1;]]>
              </WhileExp>
            </Repeat>
          </OnRender>
          <Definitions>
            <Array Name="Input" Dimensions="2" SizeDim1="2" SizeDim2="4" SizeDim3="4"/>
          </Definitions>
        </AppState>
        <AppState Comment="RayCast">
          <OnStart>
            <ZLibrary Comment="RayCast Library">
              <Source>
<![CDATA[//

void Sub(int K,
         float X1, float Y1, float Z1,
         float X2, float Y2, float Z2)
{
  RCVector[K,0] = X1-X2;
  RCVector[K,1] = Y1-Y2;
  RCVector[K,2] = Z1-Z2;
}

//

void Cross(int K,
           float X1, float Y1, float Z1,
           float X2, float Y2, float Z2)
{
  RCVector[K,0] = Y1*Z2-Z1*Y2;
  RCVector[K,1] = Z1*X2-X1*Z2;
  RCVector[K,2] = X1*Y2-Y1*X2;
}

//

float Dot(float X1, float Y1, float Z1,
          float X2, float Y2, float Z2)
{
  return X1*X2+Y1*Y2+Z1*Z2;
}

//

int RayTriangle(float OX, float OY, float OZ,
                float DX, float DY, float DZ,
                float X1, float Y1, float Z1,
                float X2, float Y2, float Z2,
                float X3, float Y3, float Z3)
{
  float R, S, T, U, V;

  Sub(1,X2,Y2,Z2,X1,Y1,Z1);
  Sub(2,X3,Y3,Z3,X1,Y1,Z1);
  
  Cross(3,DX,DY,DZ,RCVector[2,0],RCVector[2,1],RCVector[2,2]);

  R = Dot(RCVector[1,0],RCVector[1,1],RCVector[1,2],RCVector[3,0],RCVector[3,1],RCVector[3,2]);

  Sub(4,OX,OY,OZ,X1,Y1,Z1);
  S = 1/R;
  
  Cross(5,RCVector[4,0],RCVector[4,1],RCVector[4,2],RCVector[1,0],RCVector[1,1],RCVector[1,2]);
  
  if(R <= Epsilon && R >= Epsilon*-1)
  {
    return 0;
  }
  else
  {
    if(R > Epsilon)
    {
      DebugVar = U;
      U = Dot(RCVector[4,0],RCVector[4,1],RCVector[4,2],RCVector[3,0],RCVector[3,1],RCVector[3,2]);
      if(U < 0 || U > R)
      {
        return 0;
      }

      V = Dot(DX,DY,DZ,RCVector[5,0],RCVector[5,1],RCVector[5,2]);
      if(V < 0 || U+V > R)
      {
        return 0;
      }
    }

    if(R < Epsilon*-1)
    {
      U = Dot(RCVector[4,0],RCVector[4,1],RCVector[4,2],RCVector[3,0],RCVector[3,1],RCVector[3,2]);
      if(U > 0 || U < R)
      {
        return 0;
      }

      V = Dot(DX,DY,DZ,RCVector[5,0],RCVector[5,1],RCVector[5,2]);
      if(V > 0 || U+V < R)
      {
        return 0;
      }
    }
  }
  
  T = Dot(RCVector[2,0],RCVector[2,1],RCVector[2,2],RCVector[5,0],RCVector[5,1],RCVector[5,2]);
  U *= S;
  V *= S;
  
  return 1;
}]]>
              </Source>
            </ZLibrary>
          </OnStart>
          <OnRender>
            <UseMaterial Material="Wireframe"/>
            <Condition>
              <Expression>
<![CDATA[//

return RayTriangle(sin(App.Time)*2,0,0,
                   0,1,0,
                   1,1,0,
                   -0.5,1,1,
                   -0.5,1,-1);]]>
              </Expression>
              <OnTrue>
                <RenderSetColor Color="1 0 0 1"/>
                <RenderNet>
                  <RenderVertexExpression>
<![CDATA[//

this.Vertex.Y += 0.5;

//

this.Vertex.X = sin(App.Time)*2;]]>
                  </RenderVertexExpression>
                </RenderNet>
              </OnTrue>
              <OnFalse>
                <RenderSetColor Color="1 1 1 1"/>
                <RenderNet>
                  <RenderVertexExpression>
<![CDATA[//

this.Vertex.Y += 0.5;

//

this.Vertex.X = sin(App.Time)*2;
this.Vertex.Y *= 8;]]>
                  </RenderVertexExpression>
                </RenderNet>
              </OnFalse>
            </Condition>
            <RenderTransformGroup Translate="0 1 0" Rotate="0.25 0 0">
              <Children>
                <RenderNet>
                  <RenderVertexExpression>
<![CDATA[//

if(this.Vertex.X > 0)
{
  this.Vertex.X = 1;
  this.Vertex.Y = 0;
}]]>
                  </RenderVertexExpression>
                </RenderNet>
              </Children>
            </RenderTransformGroup>
          </OnRender>
          <Definitions>
            <Array Name="RCVector" Dimensions="1" SizeDim1="6" SizeDim2="3"/>
            <Constant Name="Epsilon" Value="0.001"/>
            <Material Name="Wireframe" WireframeWidth="1" Shading="2" Light="0" DrawBackFace="255"/>
            <Variable Name="DebugVar"/>
          </Definitions>
        </AppState>
        <AppState Comment="Trail">
          <OnStart>
            <ZExpression>
              <Expression>
<![CDATA[//

int U, V;

for(U=0; U<Mouse.SizeDim1; ++U)
{
  for(V=2; V<Mouse.SizeDim2; ++V)
  {
    Mouse[U,V] = 0;
  }
  
  Mouse[U,0] = App.MousePosition.X*16;
  Mouse[U,1] = App.MousePosition.Y*9;
}

//

MouseIndex = 0;]]>
              </Expression>
            </ZExpression>
          </OnStart>
          <OnUpdate>
            <ZExpression>
              <Expression>
<![CDATA[//

float TrailAngle;

//

Trail.YCount = Mouse.SizeDim1-2;

//

MouseIndexLast = MouseIndex;

++ MouseIndex;

if(MouseIndex > Mouse.SizeDim1-1) MouseIndex -= Mouse.SizeDim1;

//

Mouse[MouseIndex,0] = App.MousePosition.X*8;
Mouse[MouseIndex,1] = App.MousePosition.Y*6;

//

TrailAngle = atan2(Mouse[MouseIndexLast,1]-Mouse[MouseIndex,1],Mouse[MouseIndexLast,0]-Mouse[MouseIndex,0]);

Mouse[MouseIndex,2] = sin(TrailAngle)*-1;
Mouse[MouseIndex,3] = cos(TrailAngle);]]>
              </Expression>
            </ZExpression>
          </OnUpdate>
          <OnRender>
            <UseMaterial Material="TrailMaterial"/>
            <RenderNet Name="Trail" YCount="62">
              <RenderVertexExpression>
<![CDATA[//

int TrailIndex;
float TrailWidth;

//

this.Vertex.Y += 0.5;
this.Vertex.Y *= Trail.YCount;

//

TrailIndex = MouseIndex-(Trail.YCount-this.Vertex.Y);

if(TrailIndex > Mouse.SizeDim1-1) TrailIndex -= Mouse.SizeDim1-1;
if(TrailIndex < 0) TrailIndex += Mouse.SizeDim1-1;

//

TrailWidth = this.Vertex.Y/Trail.YCount;

//

if(this.Vertex.X > 0)
{
  this.Vertex.X = Mouse[TrailIndex,0]+Mouse[TrailIndex,2]*TrailWidth;
  this.Vertex.Y = Mouse[TrailIndex,1]+Mouse[TrailIndex,3]*TrailWidth;
}
else
{
  this.Vertex.X = Mouse[TrailIndex,0]-Mouse[TrailIndex,2]*TrailWidth;
  this.Vertex.Y = Mouse[TrailIndex,1]-Mouse[TrailIndex,3]*TrailWidth;
}]]>
              </RenderVertexExpression>
            </RenderNet>
          </OnRender>
          <Definitions>
            <Array Name="Mouse" Dimensions="1" SizeDim1="64" SizeDim2="4"/>
            <Variable Name="MouseIndex" Type="1"/>
            <Variable Name="MouseIndexLast" Type="1"/>
            <Bitmap Name="Bitmap" Width="0" Height="4">
              <Producers>
                <BitmapExpression>
                  <Expression>
<![CDATA[//

this.Pixel = Y;]]>
                  </Expression>
                </BitmapExpression>
              </Producers>
            </Bitmap>
            <Material Name="TrailMaterial" Light="0" ZBuffer="0">
              <Textures>
                <MaterialTexture Texture="Bitmap" TexCoords="1"/>
              </Textures>
            </Material>
          </Definitions>
        </AppState>
        <AppState Comment="ViewFrustrum Culling">
          <OnStart>
            <Group Comment="VFCMatrix Lib">
              <Children>
                <Array Name="VFCMatrix" Dimensions="2" SizeDim1="6" SizeDim2="3" SizeDim3="3"/>
                <ZLibrary Comment="VFCMatrix">
                  <Source>
<![CDATA[// ================================================================
// MATRIX LIBRARY by kjell
// ================================================================

void RotationMatrixX(int K, float Angle)
{
  float C, S;

  C = cos(Angle);
  S = sin(Angle);

  VFCMatrix[K,0,0] = 1;
  VFCMatrix[K,0,1] = 0;
  VFCMatrix[K,0,2] = 0;

  VFCMatrix[K,1,0] = 0;
  VFCMatrix[K,1,1] = C;
  VFCMatrix[K,1,2] = S*-1;

  VFCMatrix[K,2,0] = 0;
  VFCMatrix[K,2,1] = S;
  VFCMatrix[K,2,2] = C;
}

void RotationMatrixY(int K, float Angle)
{
  float C, S;

  C = cos(Angle);
  S = sin(Angle);

  VFCMatrix[K,0,0] = C;
  VFCMatrix[K,0,1] = 0;
  VFCMatrix[K,0,2] = S;

  VFCMatrix[K,1,0] = 0;
  VFCMatrix[K,1,1] = 1;
  VFCMatrix[K,1,2] = 0;

  VFCMatrix[K,2,0] = S*-1;
  VFCMatrix[K,2,1] = 0;
  VFCMatrix[K,2,2] = C;
}

void RotationMatrixZ(int K, float Angle)
{
  float C, S;
 
  C = cos(Angle);
  S = sin(Angle);
 
  VFCMatrix[K,0,0] = C;
  VFCMatrix[K,0,1] = S*-1;
  VFCMatrix[K,0,2] = 0;
 
  VFCMatrix[K,1,0] = S;
  VFCMatrix[K,1,1] = C;
  VFCMatrix[K,1,2] = 0;
 
  VFCMatrix[K,2,0] = 0;
  VFCMatrix[K,2,1] = 0;
  VFCMatrix[K,2,2] = 1;
}

//

void MultiplyMatrix(int K, int A, int B)
{
  VFCMatrix[K,0,0] = VFCMatrix[A,0,0]*VFCMatrix[B,0,0]+VFCMatrix[A,0,1]*VFCMatrix[B,1,0]+VFCMatrix[A,0,2]*VFCMatrix[B,2,0];
  VFCMatrix[K,0,1] = VFCMatrix[A,0,0]*VFCMatrix[B,0,1]+VFCMatrix[A,0,1]*VFCMatrix[B,1,1]+VFCMatrix[A,0,2]*VFCMatrix[B,2,1];
  VFCMatrix[K,0,2] = VFCMatrix[A,0,0]*VFCMatrix[B,0,2]+VFCMatrix[A,0,1]*VFCMatrix[B,1,2]+VFCMatrix[A,0,2]*VFCMatrix[B,2,2];
 
  VFCMatrix[K,1,0] = VFCMatrix[A,1,0]*VFCMatrix[B,0,0]+VFCMatrix[A,1,1]*VFCMatrix[B,1,0]+VFCMatrix[A,1,2]*VFCMatrix[B,2,0];
  VFCMatrix[K,1,1] = VFCMatrix[A,1,0]*VFCMatrix[B,0,1]+VFCMatrix[A,1,1]*VFCMatrix[B,1,1]+VFCMatrix[A,1,2]*VFCMatrix[B,2,1];
  VFCMatrix[K,1,2] = VFCMatrix[A,1,0]*VFCMatrix[B,0,2]+VFCMatrix[A,1,1]*VFCMatrix[B,1,2]+VFCMatrix[A,1,2]*VFCMatrix[B,2,2];

  VFCMatrix[K,2,0] = VFCMatrix[A,2,0]*VFCMatrix[B,0,0]+VFCMatrix[A,2,1]*VFCMatrix[B,1,0]+VFCMatrix[A,2,2]*VFCMatrix[B,2,0];
  VFCMatrix[K,2,1] = VFCMatrix[A,2,0]*VFCMatrix[B,0,1]+VFCMatrix[A,2,1]*VFCMatrix[B,1,1]+VFCMatrix[A,2,2]*VFCMatrix[B,2,1];
  VFCMatrix[K,2,2] = VFCMatrix[A,2,0]*VFCMatrix[B,0,2]+VFCMatrix[A,2,1]*VFCMatrix[B,1,2]+VFCMatrix[A,2,2]*VFCMatrix[B,2,2];
}

//

void Rotate(float VX, float VY, float VZ, float AX, float AY, float AZ)
{
  RotationMatrixX(1,AX);
  RotationMatrixY(2,AY);
  RotationMatrixZ(3,AZ);
 
  MultiplyMatrix(4,1,2);
  MultiplyMatrix(5,4,3);
 
  VFCMatrix[0,0,0] = VX*VFCMatrix[5,0,0]+VY*VFCMatrix[5,0,1]+VZ*VFCMatrix[5,0,2];
  VFCMatrix[0,1,0] = VX*VFCMatrix[5,1,0]+VY*VFCMatrix[5,1,1]+VZ*VFCMatrix[5,1,2];
  VFCMatrix[0,2,0] = VX*VFCMatrix[5,2,0]+VY*VFCMatrix[5,2,1]+VZ*VFCMatrix[5,2,2];
}]]>
                  </Source>
                </ZLibrary>
                <ZLibrary Comment="VFCMatrix Addon">
                  <Source>
<![CDATA[// ================================================================
// MATRIX LIBRARY AddOn
// ================================================================

// rotate in succession, first x, then y. no z.
void successiveRotation( float VX, float VY, float VZ, float AX, float AY ){
  Rotate( VX, VY, VZ, AX, 0, 0 );
  Rotate( VFCMatrix[ 0, 0, 0 ], VFCMatrix[ 0, 1, 0 ], VFCMatrix[ 0, 2, 0 ], 0,  AY, 0 );
}
// rotate in succession using the current view frustrum rotation as angles
void successiveViewRotation( float VX, float VY, float VZ ){
  successiveRotation( VX, VY, VZ, viewRotation[ 1 ] * Pi * 2, viewRotation[ 0 ] * Pi * 2 );
}]]>
                  </Source>
                </ZLibrary>
                <ZLibrary Comment="Vector (Dot Product)">
                  <Source>
<![CDATA[// ================================================================
// parts of VECTOR LIBRARY by kjell
// ================================================================

float Dot(float X1, float Y1, float Z1,
          float X2, float Y2, float Z2)
{
  return X1*X2+Y1*Y2+Z1*Z2;
}
float shortDot( int c, int n ){
  return  Dot( cubePositions[ c, 0 ],
               cubePositions[ c, 1 ],
               cubePositions[ c, 2 ],
               aFrustrumNormalsTransformed[ n, 0 ],
               aFrustrumNormalsTransformed[ n, 1 ],
               aFrustrumNormalsTransformed[ n, 2 ]);
}]]>
                  </Source>
                </ZLibrary>
              </Children>
            </Group>
            <Group Comment="View">
              <Children>
                <Variable Name="viewAngle"/>
                <Variable Name="viewRatio"/>
                <Array Name="viewRotation" SizeDim1="2"/>
                <Array Name="camRotation" SizeDim1="2"/>
                <Array Name="aFrustrumNormals" Dimensions="1" SizeDim1="4" SizeDim2="3" Persistent="255">
                  <Values>
<![CDATA[78DA636068D8CF000620BAC11EC1868BC1D8F608360200005C1F08F9]]>
                  </Values>
                </Array>
                <Array Name="aFrustrumNormalsTransformed" Dimensions="1" SizeDim1="4" SizeDim2="3"/>
                <ZExpression Comment="init">
                  <Expression>
<![CDATA[viewAngle = 0.125; // don't touch - this is not dynamic yet, sorry!
viewRatio = tan( viewAngle * 2 * PI );]]>
                  </Expression>
                </ZExpression>
              </Children>
            </Group>
            <Array Name="cubePositions" Dimensions="1" SizeDim1="1000" SizeDim2="3"/>
            <Repeat Comment="fill Cubes">
              <WhileExp>
<![CDATA[//this.Iteration=current iteration nr. Return false to end loop.
int i = this.iteration;

if( i < 1000 ){
  cubePositions[ i, 0 ] =( i -( floor( i / 10.0 )* 10 ))/5 - 1; 
  cubePositions[ i, 1 ] =( floor( i / 10.0 )-( floor( i / 100.0 )*10 ))/5 - 1;
  cubePositions[ i, 2 ] =( floor( i / 100.0 ))/5 - 1;
  return 1; }
else return 0;]]>
              </WhileExp>
            </Repeat>
            <ZExpression Comment="center mouse" Expression="//centerMouse();"/>
            <SpawnModel Model="modelFrustum" SpawnStyle="1"/>
          </OnStart>
          <OnUpdate>
            <ZExpression Comment="update camera">
              <Expression>
<![CDATA[camRotation[ 0 ] += App.MousePosition.X / 4;
camRotation[ 1 ] += App.MousePosition.Y / 4;
//centerMouse();

float dist = 2.5;
App.CameraPosition.X = sin( camRotation[ 0 ] * 2 * PI ) * cos( camRotation[ 1 ] * 2 * PI ) * dist;
App.CameraPosition.Z = cos( camRotation[ 0 ] * 2 * PI ) * cos( camRotation[ 1 ] * 2 * PI ) * dist;
App.CameraPosition.Y = sin( camRotation[ 1 ] * 2 * PI ) * dist;
App.CameraRotation.Y = -1 * camRotation[ 0 ];
App.CameraRotation.X = camRotation[ 1 ];]]>
              </Expression>
            </ZExpression>
            <Group Comment="Keys">
              <Children>
                <KeyPress Comment="Left" Keys="&lt;">
                  <OnPressed>
                    <ZExpression Expression="viewRotation[ 0 ] += App.DeltaTime / 4;"/>
                  </OnPressed>
                </KeyPress>
                <KeyPress Comment="Right" Keys="&gt;">
                  <OnPressed>
                    <ZExpression Expression="viewRotation[ 0 ] -= App.DeltaTime / 4;"/>
                  </OnPressed>
                </KeyPress>
                <KeyPress Comment="Up" Keys="^">
                  <OnPressed>
                    <ZExpression Expression="viewRotation[ 1 ] -= App.DeltaTime / 4;"/>
                  </OnPressed>
                </KeyPress>
                <KeyPress Comment="Down" Keys="_">
                  <OnPressed>
                    <ZExpression Expression="viewRotation[ 1 ] += App.DeltaTime / 4;"/>
                  </OnPressed>
                </KeyPress>
              </Children>
            </Group>
          </OnUpdate>
          <OnRender>
            <UseMaterial Material="matSmooth"/>
            <ZExpression Comment="transform frustrum normals">
              <Expression>
<![CDATA[// Rotate the frustrum plane normals.
for( int i = 0; i < aFrustrumNormals.SizeDim1; ++i ){
  successiveViewRotation( aFrustrumNormals[ i, 0 ], aFrustrumNormals[ i, 1 ], aFrustrumNormals[ i, 2 ]);
  aFrustrumNormalsTransformed[ i, 0 ] = VFCMatrix[ 0, 0, 0 ];
  aFrustrumNormalsTransformed[ i, 1 ] = VFCMatrix[ 0, 1, 0 ];
  aFrustrumNormalsTransformed[ i, 2 ] = VFCMatrix[ 0, 2, 0 ];
}]]>
              </Expression>
            </ZExpression>
            <Repeat Name="rpt_Cubes">
              <OnIteration>
                <Condition Comment="culling">
                  <Expression>
<![CDATA[int c = rpt_Cubes.iteration;
int temp = 0;

// check for all four frustrum planes (no far & near plane for now...)
for( int n = 0; n < 4; ++n )
  temp +=( shortDot( c, n ) <= 0 );  
// transfer properties if cube lies in view frustrum  
if( temp == 4 ){  
  rtg_Cube.Translate.X = cubePositions[ c, 0 ];
  rtg_Cube.Translate.Y = cubePositions[ c, 1 ];
  rtg_Cube.Translate.Z = cubePositions[ c, 2 ];
  return 1;
}
else return 0;]]>
                  </Expression>
                  <OnTrue>
                    <RenderTransformGroup Name="rtg_Cube" Scale="0.08 0.08 0.08">
                      <Children>
                        <RenderMesh Mesh="meshBox"/>
                      </Children>
                    </RenderTransformGroup>
                  </OnTrue>
                </Condition>
              </OnIteration>
              <WhileExp>
<![CDATA[//this.Iteration=current iteration nr. Return false to end loop.
if( this.Iteration < cubePositions.SizeDim1 ) return 1;
else return 0;]]>
              </WhileExp>
            </Repeat>
            <ZExpression Comment="test box">
              <Expression>
<![CDATA[successiveViewRotation( 0, 0, 1.5 );
rtg_TestBox.Translate.X = VFCMatrix[ 0, 0, 0 ];
rtg_TestBox.Translate.Y = VFCMatrix[ 0, 1, 0 ];
rtg_TestBox.Translate.Z = VFCMatrix[ 0, 2, 0 ];]]>
              </Expression>
            </ZExpression>
            <RenderTransformGroup Name="rtg_TestBox" Scale="0.02 0.02 0.02">
              <Children>
                <RenderSetColor Color="1 0 0 1"/>
                <RenderMesh Mesh="meshBox"/>
              </Children>
            </RenderTransformGroup>
            <UseMaterial Material="matSmooth"/>
            <RenderText TextFloatRef="App FpsCounter" X="-1" Y="0.95" Align="1"/>
          </OnRender>
          <Definitions>
            <Mesh Name="meshFrustrum">
              <Producers>
                <MeshBox/>
                <MeshExpression>
                  <Expression>
<![CDATA[//V : current vertex
//N : current normal (turn off AutoNormals when modifying normals)
//C : current color (turn on VertexColors)

if( this.V.Z < 0 ){
  this.V.Z = 0;
  this.V.X = 0;
  this.V.Y = 0;
  //this.C = 1;
  }

if( this.V.Z > 0 ){
  // float ratio = tan( viewAngle * 2 * PI );
  this.V.Z = 1;
  this.V.X *= viewRatio;
  this.V.Y *= viewRatio;
  // this.C = .5;
  // this.C.B = 0;
  }]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Mesh Name="meshBox">
              <Producers>
                <MeshBox/>
              </Producers>
            </Mesh>
            <Model Name="modelFrustum">
              <OnRender>
                <ZExpression Comment="update rotation">
                  <Expression>
<![CDATA[rtg_FrustrumX.Rotate.Y = viewRotation[ 0 ];
rtg_FrustrumY.Rotate.X = viewRotation[ 1 ];]]>
                  </Expression>
                </ZExpression>
                <RenderTransformGroup Name="rtg_FrustrumX">
                  <Children>
                    <RenderTransformGroup Name="rtg_FrustrumY">
                      <Children>
                        <UseMaterial Material="matWireframe"/>
                        <RenderSetColor Color="0 0 1 1"/>
                        <RenderMesh Mesh="meshFrustrum"/>
                      </Children>
                    </RenderTransformGroup>
                  </Children>
                </RenderTransformGroup>
              </OnRender>
            </Model>
            <Material Name="matWireframe" WireframeWidth="1" Shading="2" Light="0" DrawBackFace="255"/>
            <Material Name="matSmooth" Color="0.7529 0.7529 0.7529 1"/>
          </Definitions>
        </AppState>
      </Children>
    </Group>
    <Group Comment="Libraries">
      <Children>
        <Group Name="BitLibraryGroup" Comment="Bit Library">
          <Children>
            <Array Name="Bit" Type="1" SizeDim1="8"/>
            <ZLibrary Comment="Bit Library">
              <Source>
<![CDATA[/*
Small library for converting a bit field into a integer and back.
Convenient for saving memory when dealing with large amounts of booleans and / or 4D boolean Arrays.
Requires a 1D Array called "Bit" to return the values to. Function arguments and results are in big-endian ..
*/

int bit4(int A, int B, int C, int D)
{
  return A*1+
         B*2+
         C*4+
         D*8;
}

int bit8(int A, int B, int C, int D,
         int E, int F, int G, int H)
{
  return A*  1+
         B*  2+
         C*  4+
         D*  8+
         E* 16+
         F* 32+
         G* 64+
         H*128;
}

int bitX(int B)
{
  int V = 0;

  for(--B; B>=0; --B)
  {
    V += Bit[B]*pow(2,B);
  }

  return V;
}

void bitField(int X, int B)
{
  for(--B; B>=0; --B)
  {
    int V = pow(2,B);

    if(X >= V)
    {
      Bit[B] = 1;
      X -= V;
    }
    else Bit[B] = 0;
  }
}]]>
              </Source>
            </ZLibrary>
          </Children>
        </Group> <!-- BitLibraryGroup -->

        <Group Name="HsvColorGroup" Comment="HSV Color Library">
          <Children>
            <Array Name="Color" SizeDim1="3"/>
            <ZLibrary Comment="HSV Library">
              <Source>
<![CDATA[//

float angle(float X)
{
  if(X >= 0 && X < 360)return X;
  if(X > 360)return X-floor(X/360)* 360;
  if(X <   0)return X+floor(X/360)*-360;
}

//

void hsv(float H, float S, float V)
{
  float R,G,B,I,F,P,Q,T;
  
  H = angle(H);
  S = clamp(S,0,100);
  V = clamp(V,0,100);

  H /= 60;
  S /= 100;
  V /= 100;
  
  if(S == 0)
  {
    Color[0] = V;
    Color[1] = V;
    Color[2] = V;
    return;
  }

  I = floor(H);
  F = H-I;

  P = V*(1-S);
  Q = V*(1-S*F);
  T = V*(1-S*(1-F));

  if(I == 0){R = V; G = T; B = P;}
  if(I == 1){R = Q; G = V; B = P;}
  if(I == 2){R = P; G = V; B = T;}
  if(I == 3){R = P; G = Q; B = V;}
  if(I == 4){R = T; G = P; B = V;}
  if(I == 5){R = V; G = P; B = Q;}
  
  Color[0] = R;
  Color[1] = G;
  Color[2] = B;
}]]>
              </Source>
            </ZLibrary>
          </Children>
        </Group> <!-- HsvColorGroup -->

        <Group Name="MatrixLibraryGroup" Comment="Matrix Library">
          <Children>
            <Array Name="Matrix" Dimensions="2" SizeDim1="6" SizeDim2="3" SizeDim3="3"/>
            <ZLibrary Comment="Matrix Library">
              <Source>
<![CDATA[//

void RotationMatrixX(int K, float Angle)
{
  float C, S;

  C = cos(Angle);
  S = sin(Angle);

  Matrix[K,0,0] = 1;
  Matrix[K,0,1] = 0;
  Matrix[K,0,2] = 0;

  Matrix[K,1,0] = 0;
  Matrix[K,1,1] = C;
  Matrix[K,1,2] = S*-1;

  Matrix[K,2,0] = 0;
  Matrix[K,2,1] = S;
  Matrix[K,2,2] = C;
}

void RotationMatrixY(int K, float Angle)
{
  float C, S;

  C = cos(Angle);
  S = sin(Angle);

  Matrix[K,0,0] = C;
  Matrix[K,0,1] = 0;
  Matrix[K,0,2] = S;

  Matrix[K,1,0] = 0;
  Matrix[K,1,1] = 1;
  Matrix[K,1,2] = 0;

  Matrix[K,2,0] = S*-1;
  Matrix[K,2,1] = 0;
  Matrix[K,2,2] = C;
}

void RotationMatrixZ(int K, float Angle)
{
  float C, S;
  
  C = cos(Angle);
  S = sin(Angle);
  
  Matrix[K,0,0] = C;
  Matrix[K,0,1] = S*-1;
  Matrix[K,0,2] = 0;
  
  Matrix[K,1,0] = S;
  Matrix[K,1,1] = C;
  Matrix[K,1,2] = 0;
  
  Matrix[K,2,0] = 0;
  Matrix[K,2,1] = 0;
  Matrix[K,2,2] = 1;
}

//

void MultiplyMatrix(int K, int A, int B)
{
  Matrix[K,0,0] = Matrix[A,0,0]*Matrix[B,0,0]+Matrix[A,0,1]*Matrix[B,1,0]+Matrix[A,0,2]*Matrix[B,2,0];
  Matrix[K,0,1] = Matrix[A,0,0]*Matrix[B,0,1]+Matrix[A,0,1]*Matrix[B,1,1]+Matrix[A,0,2]*Matrix[B,2,1];
  Matrix[K,0,2] = Matrix[A,0,0]*Matrix[B,0,2]+Matrix[A,0,1]*Matrix[B,1,2]+Matrix[A,0,2]*Matrix[B,2,2];
  
  Matrix[K,1,0] = Matrix[A,1,0]*Matrix[B,0,0]+Matrix[A,1,1]*Matrix[B,1,0]+Matrix[A,1,2]*Matrix[B,2,0];
  Matrix[K,1,1] = Matrix[A,1,0]*Matrix[B,0,1]+Matrix[A,1,1]*Matrix[B,1,1]+Matrix[A,1,2]*Matrix[B,2,1];
  Matrix[K,1,2] = Matrix[A,1,0]*Matrix[B,0,2]+Matrix[A,1,1]*Matrix[B,1,2]+Matrix[A,1,2]*Matrix[B,2,2];

  Matrix[K,2,0] = Matrix[A,2,0]*Matrix[B,0,0]+Matrix[A,2,1]*Matrix[B,1,0]+Matrix[A,2,2]*Matrix[B,2,0];
  Matrix[K,2,1] = Matrix[A,2,0]*Matrix[B,0,1]+Matrix[A,2,1]*Matrix[B,1,1]+Matrix[A,2,2]*Matrix[B,2,1];
  Matrix[K,2,2] = Matrix[A,2,0]*Matrix[B,0,2]+Matrix[A,2,1]*Matrix[B,1,2]+Matrix[A,2,2]*Matrix[B,2,2];
}

//

void Rotate(float VX, float VY, float VZ, float AX, float AY, float AZ)
{
  RotationMatrixX(1,AX);
  RotationMatrixY(2,AY);
  RotationMatrixZ(3,AZ);
  
  MultiplyMatrix(4,1,2);
  MultiplyMatrix(5,4,3);
  
  Matrix[0,0,0] = VX*Matrix[5,0,0]+VY*Matrix[5,0,1]+VZ*Matrix[5,0,2];
  Matrix[0,1,0] = VX*Matrix[5,1,0]+VY*Matrix[5,1,1]+VZ*Matrix[5,1,2];
  Matrix[0,2,0] = VX*Matrix[5,2,0]+VY*Matrix[5,2,1]+VZ*Matrix[5,2,2];
}]]>
              </Source>
            </ZLibrary>
          </Children>
        </Group> <!-- MatrixLibraryGroup -->

        <Group Name="VectorLibraryGroup" Comment="Vector Library">
          <Children>
            <Array Name="Vector" Dimensions="1" SizeDim1="6" SizeDim2="3"/>
            <ZLibrary Comment="Vector Library">
              <Source>
<![CDATA[//

void Sub(int K,
         float X1, float Y1, float Z1,
         float X2, float Y2, float Z2)
{
  Vector[K,0] = X1-X2;
  Vector[K,1] = Y1-Y2;
  Vector[K,2] = Z1-Z2;
}

//

void Cross(int K,
           float X1, float Y1, float Z1,
           float X2, float Y2, float Z2)
{
  Vector[K,0] = Y1*Z2-Z1*Y2;
  Vector[K,1] = Z1*X2-X1*Z2;
  Vector[K,2] = X1*Y2-Y1*X2;
}

//

float Dot(float X1, float Y1, float Z1,
          float X2, float Y2, float Z2)
{
  return X1*X2+Y1*Y2+Z1*Z2;
}

//

float getLength( float X, float Y, float Z ){
  float length = sqrt( pow( X, 2 ) + pow( Y, 2 ) + pow( Z, 2 ));
  return length;
}

// normalize
void Normalize( int K,
                float X, float Y, float Z ){
  float length = getLength( X, Y, Z );
  if( length == 0 ) return;
  Vector[ K, 0 ] = X / length;
  Vector[ K, 1 ] = Y / length;
  Vector[ K, 2 ] = Z / length;
  }]]>
              </Source>
            </ZLibrary>
          </Children>
        </Group> <!-- VectorLibraryGroup -->

      </Children>
    </Group>
    <Group Comment="External libraries">
      <Children>
        <ZExternalLibrary Comment="OpenGL 4.0 graphics" ModuleName="opengl32" DefinitionsFile="opengl.txt">
          <BeforeInitExp>
<![CDATA[if(ANDROID) {
  if(App.GLBase==0)
    this.ModuleName="libGLESv1_CM.so";
  else
    this.ModuleName="libGLESv2.so";
}]]>
          </BeforeInitExp>
        </ZExternalLibrary>
        <ZExternalLibrary Comment="Bullet 3D physics" ModuleName="ZGEBullet" CallingConvention="1" DefinitionsFile="zgebullet.txt"/>
        <ZExternalLibrary Comment="Bass music player" ModuleName="bass.dll">
          <BeforeInitExp>
<![CDATA[if(ANDROID)
  this.ModuleName = "./libbass.so";]]>
          </BeforeInitExp>
          <Source>
<![CDATA[//BASS-dll from http://www.un4seen.com/
int BASS_GetVersion() { }

int BASS_ErrorGetCode() { }

int BASS_Free() { }
int BASS_Stop() { }

int BASS_Init(int device, int freq, int flags, int win, int clsid) { }

int BASS_MusicLoad(int mem, string filename, int of1, int of2, int length, int flags, int freq) { }

int BASS_ChannelPlay(int handle, int restart) { }
int BASS_ChannelGetLevel(int handle) { }]]>
          </Source>
        </ZExternalLibrary>
        <ZExternalLibrary Comment="Box2D physics" ModuleName="Box2DZGE.dll">
          <Source>
<![CDATA[//Box2D physics integration
//Get the DLL from here:
//
//   http://www.emix8.org/forum/viewtopic.php?t=586

// ================== WORLD
// init the world
void b2dll_InitWorld( float aabbxl, float aabbxh, // bounding box x limits
                      float aabbyl, float aabbyh, // bounding box y limits
                      float gx, float gy, // gravity vector (default [ 0, -10 ])
                      int doSleep ){ } // turn off simulation of resting bodies (default on)
// advance the simulation
void b2dll_Step( float timestep, int iterations ){ }
// count bodies
int b2dll_GetBodyCount( ){ }

// ================== BODIES
// create a static box (e.g. ground)
int b2dll_CreateStaticBox( float x, float y,
                           float width, float height ){ }
// create a dynamic box
int b2dll_CreateDynamicBox( float x, float y, // position
                            float width, float height ){ } // dimension
// getters
float b2dll_GetPositionX( int body ){ }
float b2dll_GetPositionY( int body ){ }
float b2dll_GetAngle( int body ){ }]]>
          </Source>
        </ZExternalLibrary>
        <ZExternalLibrary Comment="SunVox music library" ModuleName="sunvox">
          <Source>
<![CDATA[/*
  Adapter to the SunVox Dynamic Library.
  http://http://www.warmplace.ru/soft/sunvox

  Created by Rado1(c)2012

  Download DLL from http://www.warmplace.ru/soft/beta/sunvox_dll_win32.zip
  More info: http://www.emix8.org/forum/viewtopic.php?p=5446

*/

// Constants

const int SV_NOTECMD_NOTE_OFF = 128;
const int SV_NOTECMD_ALL_NOTES_OFF  = 129; // notes of all synths off
const int SV_NOTECMD_CLEAN_SYNTHS = 130; // stop and clean all synths
const int SV_NOTECMD_STOP = 131;
const int SV_NOTECMD_PLAY = 132;

const int SV_INIT_FLAG_NO_DEBUG_OUTPUT = 1 << 0;
const int SV_INIT_FLAG_USER_AUDIO_CALLBACK = 1 << 1;
const int SV_INIT_FLAG_AUDIO_INT16 = 1 << 2;
const int SV_INIT_FLAG_AUDIO_FLOAT32 = 1 << 3;
const int SV_INIT_FLAG_ONE_THREAD =  1 << 4;

// Initialization functions

int sv_init(string dev, int freq, int channels, int flags) {}
int sv_deinit() {}
int sv_open_slot(int slot) {}
int sv_close_slot(int slot) {}

// Functions to control song playing

int sv_load(int slot, string name) {}
int sv_play(int slot) {}
int sv_play_from_beginning(int slot) {}
int sv_stop(int slot) {}
int sv_set_autostop(int slot, int autostop) {}
  // autostop values: 0 - disable autostop; 1 - enable autostop.
  // When disabled, song is playing infinitely in the loop.
int sv_rewind(int slot, int t) {}
int sv_volume(int slot, int vol) {}
int sv_send_event(int slot, int channel_num, int note, int vel, int module, int ctl, int ctl_val) {}

// Functions to get info about the engine, song and its playing

int sv_end_of_song(int slot) {}
  // Return values: 0 - song is playing now; 1 - stopped.
int sv_get_current_line(int slot) {}
int sv_get_current_signal_level(int slot, int channel) {}
string sv_get_song_name(int slot) {}
int sv_get_song_bpm(int slot) {}
int sv_get_song_tpl(int slot) {}
int sv_get_song_length_lines(int slot) {}
int sv_get_song_length_frames(int slot) {}
  // Frame is one discrete of the sound. Sampling frequency 44100 Hz
  // means, that you hear 44100 frames per second.
int sv_get_ticks() {}
  // Returns the current tick counter (from 0 to 0xFFFFFFFF).
  // SunVox engine uses its own time space, measured in ticks.
int sv_get_ticks_per_second() {}
  // Returns the number of SunVox ticks per second.
int sv_get_number_of_modules(int slot) {}
int sv_get_module_flags(int slot, int mod_num) {}
string sv_get_module_name(int slot, int mod_num) {}]]>
          </Source>
        </ZExternalLibrary>
        <ZExternalLibrary Comment="ZGESensor library" ModuleName="./libZGESensor.so" CallingConvention="1">
          <Source>
<![CDATA[/*
  ZGESensor Library used to handle various sensors on Android.

  Download Android shared library from
  http://code.google.com/p/zgesensor/downloads

  Copyright (c) 2013 Radovan Cervenka
*/

// sensor types; also used as sensor identifiers
const int SENSOR_TYPE_ACCELEROMETER = 1;
const int SENSOR_TYPE_MAGNETIC_FIELD = 2;
const int SENSOR_TYPE_ORIENTATION = 3; // deprecated
const int SENSOR_TYPE_GYROSCOPE = 4;
const int SENSOR_TYPE_LIGHT = 5;
const int SENSOR_TYPE_PROXIMITY = 8;
const int SENSOR_TYPE_ROTATION_VECTOR = 11;
const int SENSOR_TYPE_RELATIVE_HUMIDITY = 12;
const int SENSOR_TYPE_PRESSURE = 6;
const int SENSOR_TYPE_LINEAR_ACCELERATION = 10;
const int SENSOR_TYPE_GRAVITY = 9;
const int SENSOR_TYPE_AMBIENT_TEMPERATURE = 13;

// Initialize the library.
void sensorInitLib() {}

// Stop the library usage. Returns a negative error code on failure.
int sensorStopLib() {}

// Start to use sensor of the specified type.
// Returns a negative error code on failure.
int sensorUse(int type) {}

// Set the delivery rate of events in microseconds for a sensor
// of the given type.
// Returns a negative error code on failure.
int sensorSetEventRate(int type, float eventRate) {}

// Disable a sensor of the specified type.
// Returns a negative error code on failure.
int sensorDisable(int type) {}

// Enable a sensor of the specified type.
// Returns a negative error code on failure.
int sensorEnable(int type) {}

// Update actual data for all the used sensors.
// Usually called in ZApplication's or AppState's OnUpdate section.
// Returns number of processes events.
int sensorUpdateData() {}

/*
 * Get actual data for the selected scalar sensor type.
 * This is used for sensors such as ambient temperature,
 * proximity, light, pressure or humidity.
 */
void sensorGetData1(int type, ref float value) {}

/*
 * Get actual data for the selected 3D sensor type.
 * This is used for sensors such as accelerometer, magnetic field,
 * gyroscope, or gravity.
 */
void sensorGetData3(int type, ref float x, ref float y, ref float z) {}

/*
 * Get actual data for the selected 3D sensor type.
 * Rotation vector sensor uses <x, y, z, w> as components of
 * a unit quaternion representing rotation of the device.
 */
void sensorGetData4(int type, ref float x, ref float y, ref float z, ref float w) {}

// Return name of a sensor of the specified type.
string sensorGetName(int type) {}

// Return vendor's name of a sensor of the specified type.
string sensorGetVendor(int type) {}

// Return resolution of a sensor of the specified type.
float sensorGetResolution(int type) {}

/*
 * Return the minimum delay allowed between events in microseconds for
 * a sensor of the specified type.
 */
float sensorGetMinDelay(int type) {}]]>
          </Source>
        </ZExternalLibrary>
      </Children>
    </Group>
    <Group Comment="Fonts">
      <Children>
        <Group Name="DinaFontGroup" Comment="Dina">
          <Children>
            <Font Name="DinaFont" Bitmap="DinaBitmap" FirstChar="32" CharPixelWidth="8" CharPixelHeight="16"/>
            <Bitmap Name="DinaBitmap" Comment="Font from http://www.donationcoder.com/Software/Jibz/Dina/index.html" Width="3" Height="3" Filter="1">
              <Producers>
                <BitmapFromFile Transparency="1">
                  <BitmapFile>
<![CDATA[78DAED5DDB96E3200CE3FF7F7AF66DCF9C6930B27C011AF969A64D49A2185F844DC69048241289E42DF2F34BC0837FFF810FFEF91364846628F69EF1FFBF8F57F2F9EDF282ED038EC21F57C29EC7F1792538EC20C8E7E03F9BA48FF3F76722E9F6C7981DAE93CE0E93FEBB9493B03FCBD14E7B04D583FFB9EB6AFB8F18B7D3BC7027FE5BE29FA5A1FB02908DF97E9497CFB263F6C1C1994BF8115BC93FCD4EB5E90323AB443FCED9D88DDA58743D360E2ECD37F09F6994EBABB7E5DDEF71BE1289E48BED18EE2C246D79AB2B2E92D0544C1CFF59724A8CEF4A7E0745A6E1F11B411212D444B5FED7E16F2F88C42968EF1C8FD3B915B4460A7F9BA27B89CA530DDAD5F82FCF5884FF2DFACFADBC18A11AB838FB6709A6E81164017894FE0F3FF1D5B0049912FF544FA52CFF8B78D8A0816AB0EA9D2705D785B3F0C7EB19885BDB5EDDD1A0FF5CF07C54FC7F35FE83E2759BD75FFA53E966FBCF39C7E6F517C999CCCFB1DE3CD1950BFF2B6E53F86FC71FA94B4CF4B0C2BFCDEFBBF29DD95776F18F51D7EA4AA9F038D3F87776FD447D7E29FEAEB411BC129CD705D352BBBE6579523026BC177F6F5ABA7C5E46F15204FF41D5E75F813FC7EBC6F1B727858BF6897FEEE5AB8BEC0F8DFFA3A2DAD5A45EFD373C05E1BE677E0D9C2004FECB7B8FD81F64F014FC47C6BAFFAEF86779BCD728D1F873FA734EFCF3E6DCF304FF2BFC85BFF097ECE27F24122254131AF229C23F328984E15EFD3FFF1120FC39629F91922A90325AAE47CC4E8D132048C083B73947FAEEB3F27DD7E72033839717562C5810F8D37577DCF8DE719078FB55F87BE73B81BF8B076BC0DF360EFDF877EAFF39F6E73BF097FDCFB53FCB602631FEF1AE472CEB2E1092875E2F8BE3D31936A7971B55575C77E60B445C2AFC9B33CAB6063170AAD207B80CF217F70BEC9AD4A28024128944C2C5E79DEB716FF05674F84D34A51A5BB3CEB23C246DA7F97CFC368375B606EF57877F303C23EAEA693EA701FFEA54A2223CF6F24811FCED1D6BC1FE0B425DAFC31FD7A514FC87A7FF221DFFA2B72A80C630B2FE5B8DFF58EDBF9D62C641FC830E258BCFA7F1AFE8BF08CE0BD7DD7D37FEF66DBA0C51A26B8EECB37DF27A16DD7FC1297C965FF6E2EFB2E759C7EFC29F88FF89B848E46A5628C82565C23F8BFFE1FAFD2512894422915CE4F7BDFDE3AEF8DF3829BDBF8777FF1FEF38E075D2EB2359FCB3972F0D76DAD2F59FCD75F5F8E7C1E75B5166BC0BFF7EFD8CD7F1DE823FC2639C807F90CFF1DA557C7CD77E6E2EFC233BA2180072F66724EDAB56A4FFA07921F4DF85BF519FC0BD7758F8BBECCF0CFFACBE0C6EDFA493E31F047F504F1EF704E3F607C3FB471AE2FF94B8DD7BA90D7D6DE24B2512894422919C268A4C4E7804BB9E3BD76FEE8A6F893E77049FE538B8AA2FA740B01FD64BCF8EBC82F3B1A38FC0F815817FBC453A8EFFA8E91349E7F3D30D4BD1FB37973432DDF1B4B45717E1EFEA63F2CEC4E16F61589AE2A5CD89BC6733B8EF4A9B5376191357E5B0EB2B57EF4CF0A5E134AFBBFC3C45FF6D83F3F855CA0B6B3E870A1A8A745E7DE97F73ED7F1BFF8F3B1A6E0A14EDF75514FF2C4DB177EA8171FBD2FE2F437722EFA8E0DB7BB6BB9174E6B912894422915CEDDDD2399F6552702F383DE3B7ED4E59340297F4E13C7C967635E0EF852225E08FE3FFB86F06B26340D6456665BE41FCAB8D00B29FBC412E75E24F90BD771961702B98D97E4A0DFA8F932D7B1F41B5FD6FA0C5B8BAD3E07CEFC7DFEE53B3DFE7DE89FF5EFD1F65EB9888FF9D1DD96C7F76D9FFEDF8DF1BFFEC7A04F624F56E31140FFBBFE3FDB0CDF837E4A1D76D329F32DFFBEF2E52DAF42A424682C83F99AF58DD]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Material Name="DinaMaterial" Shading="1" Light="0" Font="DinaFont"/>
          </Children>
        </Group> <!-- DinaFontGroup -->

      </Children>
    </Group>
    <ZExpression Comment="Authors and Credits">
      <Expression>
<![CDATA[/*

Authors:
Kjell         (http://www.emix8.org/forum/profile.php?mode=viewprofile&u=55)
jph_wacheski  (http://www.emix8.org/forum/profile.php?mode=viewprofile&u=54)
Kattle87      (http://www.emix8.org/forum/profile.php?mode=viewprofile&u=47)
y offs et     (http://www.emix8.org/forum/profile.php?mode=viewprofile&u=80)
diki          (http://www.emix8.org/forum/profile.php?mode=viewprofile&u=67)

Code:
Bitmaps
  Anti-Aliased Circle (http://www.emix8.org/forum/viewtopic.php?t=137) Kjell
  Bricks (http://www.emix8.org/forum/viewtopic.php?t=347) Kattle87
  Dithering (http://www.emix8.org/forum/viewtopic.php?t=541) Kjell
  Polygon Bitmap (http://www.emix8.org/forum/viewtopic.php?t=561) diki
Meshes
  Better looking Spheres (http://www.emix8.org/forum/viewtopic.php?t=204) Kattle87
  Capsule (http://www.emix8.org/forum/viewtopic.php?p=2966#2966) Kjell
  Cylinder (http://www.emix8.org/forum/viewtopic.php?p=1629#1629) Kattle87
Models
  Ring from Cubes (http://www.emix8.org/forum/viewtopic.php?t=205) jph_wacheski
  Zwidget (http://www.emix8.org/forum/viewtopic.php?t=576) y offs et
Examples
  2D Culling (http://www.emix8.org/forum/viewtopic.php?t=491) Kjell
  GLSL Fog (http://www.emix8.org/forum/viewtopic.php?t=412) jph_wacheski
  Input Method (http://www.emix8.org/forum/viewtopic.php?t=331) Kjell
  Proportional Font (http://www.emix8.org/forum/viewtopic.php?t=551) Kjell
  RayCast (http://www.emix8.org/forum/viewtopic.php?t=392) Kjell
  Trails (http://www.emix8.org/forum/viewtopic.php?t=348) Kjell
  View Frustrum Culling (http://www.emix8.org/forum/viewtopic.php?t=513) diki
Libraries
  Bit Library (http://www.emix8.org/forum/viewtopic.php?t=532) Kjell
  HSV Color Library (http://www.emix8.org/forum/viewtopic.php?t=557) Kjell
  Matrix Library (http://www.emix8.org/forum/viewtopic.php?t=389) Kjell
  Vector Library (http://www.emix8.org/forum/viewtopic.php?t=392) Kjell

*/]]>
      </Expression>
    </ZExpression>
  </Content>
</ZApplication>
