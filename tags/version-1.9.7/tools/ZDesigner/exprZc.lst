
================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     Zc
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 6 maj 2005 @ 16:39:13

Statistics:
  number of terminals:        73 (limit   769)
  number of non-terminals:    21 (limit   696)
  number of pragmas:           0 (limit   696)
  number of symbolnodes:      94 (limit   769)
  number of graphnodes:      204 (limit  4501)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    24 (limit   751)

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText function for case insensitive compares



================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4  (*  USES INTERFACE SysUtils *)
    5  (*  USES Implementation contnrs; *)
    6  
    7    TYPE
    8  
    9    TZcAssignType = (atAssign,atMulAssign,atDivAssign,atPlusAssign,atMinusAssign);
   10    TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus,zcConst,zcIdentifier,zcAssign,zcIf,
   11            zcCompLT,zcCompGT,zcCompLE,zcCompGE,zcCompNE,zcCompEQ,
   12            zcBlock,zcNegate,zcOr,zcAnd,zcFuncCall,zcReturn);
   13  
   14    TZcOp = class
   15    public
   16      Kind : TZcOpKind;
   17      Value : single;
   18      Id : string;
   19      Children : TList;
   20      constructor Create;
   21      destructor Destroy; override;
   22      function ToString : string;
   23      function Child(I : integer) : TZcOp;
   24      procedure Optimize;
   25    end;
   26  
   27    PUBLIC
   28      ZStatements : TList;
   29    PRIVATE
   30      procedure WriteStr(S : string);
   31      procedure WriteOp(Op : TZcOp);
   32      procedure AddGlobalStatement(Op : TZcOp);
   33      procedure CleanUp;
   34    CREATE
   35      ZStatements := TList.Create;
   36    DESTROY
   37      CleanUp;
   38    ERRORS
   39  END_DELPHI
   40  
   41  (* Arbitrary Code *)
   42  
   43  function MakeOp(Kind : TZcOpKind) : TZcOp; overload;
   44  begin
   45    Result := TZcOp.Create;
   46    Result.Kind := Kind;
   47  end;
   48  function MakeOp(Kind : TZcOpKind; Value : single) : TZcOp; overload;
   49  begin
   50    Result := MakeOp(Kind);
   51    Result.Value := Value;
   52  end;
   53  function MakeOp(Kind : TZcOpKind; Id :string) : TZcOp; overload;
   54  begin
   55    Result := MakeOp(Kind);
   56    Result.Id := Id;
   57  end;
   58  function MakeOp(Kind : TZcOpKind; const Children : array of TZcOp) : TZcOp; overload;
   59  var
   60    I : integer;
   61  begin
   62    Result := MakeOp(Kind);
   63    for I := 0 to High(Children) do
   64      Result.Children.Add(Children[I]);
   65  end;
   66  
   67  function MakeAssign(Kind : TZcAssignType; Op1,Op2 : TZcOp) : TZcOp;
   68  const
   69    AssignMap : array[TZcAssignType] of TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus);
   70  var
   71    Tmp : TZcOp;
   72  begin
   73    case Kind of
   74      atMulAssign,atDivAssign,atPlusAssign,atMinusAssign :  //Convert x*=2 to x=x*2
   75        begin
   76          Tmp := MakeOp(zcIdentifier,Op1.Id);
   77          Op2 := MakeOp(AssignMap[Kind],[Tmp,Op2]);
   78        end;
   79    end;
   80    Result := MakeOp(zcAssign,[Op1,Op2]);
   81  end;
   82  
   83  constructor TZcOp.Create;
   84  begin
   85    Children := TList.Create;
   86  end;
   87  
   88  destructor TZcOp.Destroy;
   89  var
   90    I : integer;
   91  begin
   92    for I := 0 to Children.Count-1 do
   93      if Assigned(Children[I]) then Child(I).Free;
   94    FreeAndNil(Children);
   95  end;
   96  
   97  function TZcOp.Child(I : integer) : TZcOp;
   98  begin
   99    Result := TZcOp(Children[I]);
  100  end;
  101  
  102  function TZcOp.ToString : string;
  103  var
  104    I : integer;
  105  begin
  106    case Kind of
  107      zcMul : Result := Child(0).ToString + '*' + Child(1).ToString;
  108      zcDiv : Result := Child(0).ToString + '/' + Child(1).ToString;
  109      zcPlus : Result := Child(0).ToString + '+' + Child(1).ToString;
  110      zcMinus : Result := Child(0).ToString + '-' + Child(1).ToString;
  111      zcConst : Result := FloatToStr(Value);
  112      zcIdentifier : Result := Id;
  113      zcAssign : Result := Child(0).ToString + '=' + Child(1).ToString;
  114      zcIf :
  115        begin
  116          Result := 'if(' + Child(0).ToString + ') ' + Child(1).ToString;
  117          if Assigned(Child(2)) then
  118            Result := Result + ' else ' + Child(2).ToString;
  119        end;
  120      zcCompLT : Result := Child(0).ToString + '<' + Child(1).ToString;
  121      zcCompGT : Result := Child(0).ToString + '>' + Child(1).ToString;
  122      zcCompLE : Result := Child(0).ToString + '<=' + Child(1).ToString;
  123      zcCompGE : Result := Child(0).ToString + '>=' + Child(1).ToString;
  124      zcCompNE : Result := Child(0).ToString + '!=' + Child(1).ToString;
  125      zcCompEQ : Result := Child(0).ToString + '==' + Child(1).ToString;
  126      zcBlock :
  127        begin
  128          Result := '{'#13#10;
  129          for I := 0 to Children.Count-1 do
  130            Result := Result + Child(I).ToString + '; ';
  131          Result := Result + '}'#13#10;
  132        end;
  133      zcNegate : Result := '-' + Child(0).ToString;
  134      zcOr : Result := Child(0).ToString + ' || ' + Child(1).ToString;
  135      zcAnd : Result := Child(0).ToString + ' && ' + Child(1).ToString;
  136      zcFuncCall :
  137        begin
  138          Result := Id + '(';
  139          for I := 0 to Children.Count-1 do
  140          begin
  141            if I>0 then
  142              Result := Result + ',';
  143            Result := Result + Child(I).ToString;
  144          end;
  145          Result := Result + ')';
  146        end;
  147      zcNop : Result := ';';       //Empty statement
  148      zcReturn : Result := 'return ' + Child(0).ToString + ';';
  149    end;
  150  end;
  151  
  152  procedure TZcOp.Optimize;
  153  var
  154    I : integer;
  155  
  156    procedure DoConstant(NewValue : single);
  157    begin
  158      if (Child(0).Kind=zcConst) and (Child(1).Kind=zcConst) then
  159      begin
  160        Kind := zcConst;
  161        Value := NewValue;
  162      end;
  163    end;
  164  
  165  begin
  166    for I := 0 to Children.Count-1 do
  167      if Assigned(Child(I)) then Child(I).Optimize;
  168    case Kind of
  169      //todo: more optimizations
  170      zcMul : DoConstant(Child(0).Value * Child(1).Value);
  171      zcDiv : DoConstant(Child(0).Value / Child(1).Value);
  172      zcPlus : DoConstant(Child(0).Value + Child(1).Value);
  173      zcMinus : DoConstant(Child(0).Value - Child(1).Value);
  174      zcNegate :
  175        if Child(0).Kind=zcConst then
  176        begin
  177          Kind := zcConst;
  178          Value := Child(0).Value * -1;
  179        end;
  180    end;
  181  end;
  182  
  183  procedure T-->Grammar<--.WriteStr(S : string);
  184  begin
  185    _StreamLine(S);
  186  end;
  187  
  188  procedure T-->Grammar<--.WriteOp(Op : TZcOp);
  189  begin
  190    WriteStr(Op.ToString);
  191  end;
  192  
  193  procedure T-->Grammar<--.AddGlobalStatement(Op : TZcOp);
  194  begin
  195    ZStatements.Add(Op);
  196  end;
  197  
  198  procedure T-->Grammar<--.CleanUp;
  199  var
  200    I : integer;
  201  begin
  202    for I := 0 to ZSTatements.Count-1 do TObject(ZStatements[I]).Free;
  203    ZStatements.Free;
  204  end;
  205  
  206  CHARACTERS
  207  
  208          tab                = CHR(9). /*  9 = tabulator */
  209          eol                = CHR(10). /* 10 = line feed */
  210          cr                 = CHR(13). /* 13 = carriage return */
  211          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  212  
  213          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  214          digit              = "0123456789".
  215          hexDigit           = digit + "ABCDEFabcdef".
  216          notDigit           = ANY - digit.
  217  
  218          char               = ANY - "'" - '\\' - newLine.
  219          verbatimStringChar = ANY - '"'.
  220          regularStringChar  = ANY - '"' - '\\' - newLine.
  221          notNewLine         = ANY - newLine .
  222  
  223  
  224  TOKENS
  225  
  226    /*--------------------------------------------------------------------------------*/
  227          intCon =
  228                  ( digit {digit}
  229                  | ("0x" | "0X") hexDigit {hexDigit}
  230                  )
  231                  ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  232    /*--------------------------------------------------------------------------------*/
  233          realCon =
  234                  "." digit {digit}
  235                  [("e" | "E") ["+" | "-"] digit {digit}]
  236                  ["F" | "f" | "D" | "d" | "M" | "m"]
  237          | digit {digit}
  238                  ( "." digit {digit}
  239                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  240                          ["F" | "f" | "D" | "d" | "M" | "m"]
  241                  | ("e" | "E") ["+" | "-"] digit {digit}
  242                          ["F" | "f" | "D" | "d" | "M" | "m"]
  243                  | "F" | "f" | "D" | "d" | "M" | "m"
  244                  ).
  245    /*--------------------------------------------------------------------------------*/
  246          stringCon =
  247                  '"'    { regularStringChar }
  248                  '"'.
  249  
  250          ident = ['@'] letter { letter | digit }.
  251  
  252  
  253          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  254          and    = "&".
  255          assgn  = "=".
  256          colon  = ":".
  257          comma  = ",".
  258          dec    = "--".
  259          div    = "/".
  260          dot    = ".".
  261          eq     = "==".
  262          gt     = ">".
  263          gte    = ">=".
  264          inc    = "++".
  265          lbrace = "{".
  266          lbrack = "[".
  267          lpar   = "(".
  268          lshift = "<<".
  269          lt     = "<".
  270          lte    = "<=".
  271          minus  = "-".
  272          mod    = "%".
  273          neq    = "!=".
  274          not    = "!".
  275          or     = "|".
  276          plus   = "+".
  277          rbrace = "}".
  278          rbrack = "]".
  279          rpar   = ")".
  280          rshift = ">>".
  281          scolon = ";".
  282          tilde  = "~".
  283          times  = "*".
  284          xor    = "^".
  285  
  286  
  287  
  288  COMMENTS FROM "/*" TO "*/"
  289  COMMENTS FROM "//" TO eol
  290  
  291  IGNORE eol + cr + tab
  292  
  293  PRODUCTIONS
  294  
  295  /*------------------------------------------------------------------------*
  296   *--------------------------- Declarations -------------------------------*
  297   *------------------------------------------------------------------------*/
  298  
  299  Zc      (. var Op : TZcOp; I : integer; .)
*****  ^ Zc is a deletable symbol
  300  =
  301    {EmbeddedStatement<Op>       (. AddGlobalStatement(Op); .)
  302     }
  303  
  304    (. if Successful then
  305       begin
  306         for I:=0 to ZStatements.Count-1 do
  307         begin
  308           TZcOp(ZStatements[I]).Optimize;
  309           WriteOp(TZcOp(ZStatements[I]));
  310         end;
  311       end;
  312    .)
  313  .
  314  
  315  
  316  /*------------------------------------------------------------------------*/
  317  
  318  /* LocalVarDecl
  319  = Type LocalVar {"," LocalVar}
  320  . */
  321  
  322  /*------------------------------------------------------------------------*/
  323  
  324  /* LocalVar       (. var Op : TZcOp; .)
  325  = ident [ "=" ( Init | "stackalloc" Type "[" Expr<Op> "]") ]
  326  . */
  327  
  328  /*------------------------------------------------------------------------*/
  329  
  330  /* Init           (. var Op : TZcOp; .)
  331  = Expr<Op>
  332  .  */
  333  
  334  /*------------------------------------------------------------------------*/
  335  Argument<var OutOp : TZcOp>       (. var Op : TZcOp; .)
  336  = /* ["ref" | "out"] */
  337    Expr<OutOp>
  338  .
  339  
  340  /*------------------------------------------------------------------------*
  341   *-------------------------------- Types ---------------------------------*
  342   *------------------------------------------------------------------------*/
  343  
  344  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  345   * and for array creation expressions                                     */
  346  
  347  /*
  348  Type
  349  = ( SimpleType )
  350  . */
  351  
  352  /*------------------------------------------------------------------------*/
  353  
  354  /* SimpleType
  355  = IntType | "float" | "double" | "decimal" | "bool"
  356  .  */
  357  
  358  /*------------------------------------------------------------------------*/
  359  
  360  /* IntType
  361  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  362  . */
  363  
  364  
  365  /*------------------------------------------------------------------------*
  366   *------------------------------ Statements ------------------------------*
  367   *------------------------------------------------------------------------*/
  368  
  369  Statement<var OutOp : TZcOp>               (. var Op : TZcOp; .)
  370  =
  371  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  372  /* | LocalVarDecl ";"
  373   | */
  374   EmbeddedStatement<OutOp>
  375    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  376     * ident {"." ident} { "[" ...                           */
  377  .
  378  /*------------------------------------------------------------------------*/
  379  EmbeddedStatement<var OutOp : TZcOp>
  380    (. var
  381         Op,IfOp,IfBody,ElseOp : TZcOp;
  382    .)
  383  =
  384    Block<OutOp>
  385  | ";"   (. OutOp := MakeOp(zcNop); .)
  386  | StatementExpr<OutOp> ";"
  387  | "if" (. ElseOp := nil; .)
  388    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  389          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  390  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  391  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  392  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  393  /* | "for" "(" [ForInit] ";" [Expr<Op>] ";" [ForInc] ")" EmbeddedStatement<Op> */
  394  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  395  /* | "break" ";" */
  396  /* | "continue" ";" */
  397   | "return" Expr<Op> ";"   (. OutOp := MakeOp(zcReturn,[Op]); {return måste har ett expr} .)
  398  .
  399  /*------------------------------------------------------------------------*/
  400  
  401  Block<var OutOp : TZcOp>
  402    (. var
  403         Op : TZcOp;
  404    .)
  405  = (. OutOp := MakeOp(zcBlock); .)
  406    "{" {Statement<Op> (. OutOp.Children.Add(Op); .) } "}".
  407  
  408  /*------------------------------------------------------------------------*/
  409  StatementExpr<var OutOp : TZcOp>           (. var Tmp,Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  410  =
  411    Unary<Op1>
  412    ( AssignOp<Kind> Expr<Op2>
  413      (.
  414        OutOp := MakeAssign(Kind,Op1,Op2);
  415      .)
  416    |                             (. OutOp := Op1; .)
  417    )
  418  .
  419  
  420  /*------------------------------------------------------------------------*/
  421  AssignOp<var Kind : TZcAssignType>
  422  = "="     (. Kind := atAssign; .)
  423    | "+="  (. Kind := atPlusAssign; .)
  424    | "-="  (. Kind := atMinusAssign; .)
  425    | "*="  (. Kind := atMulAssign; .)
  426    | "/="  (. Kind := atDivAssign; .)
  427  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  428  .
  429  
  430  /*------------------------------------------------------------------------*/
  431  
  432  /* SwitchSection   (. var Op : TZcOp; .)
  433  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  434  .  */
  435  
  436  /*------------------------------------------------------------------------*/
  437  
  438  /* SwitchLabel     (. var Op : TZcOp; .)
  439  = "case" Expr<Op> ":"
  440  | "default" ":"
  441  .  */
  442  
  443  /*------------------------------------------------------------------------*/
  444  
  445  /* ForInit     (. var Op : TZcOp; .)
  446  = LocalVarDecl
  447  | StatementExpr<Op> { "," StatementExpr<Op> }
  448  .  */
  449  
  450  /*------------------------------------------------------------------------*/
  451  
  452  /* ForInc      (. var Op : TZcOp; .)
  453  = StatementExpr<Op> { "," StatementExpr<Op> }
  454  .  */
  455  
  456  
  457  /*------------------------------------------------------------------------*
  458   *----------------------------- Expressions ------------------------------*
  459   *------------------------------------------------------------------------*/
  460  
  461  
  462  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  463  = Unary<Op1>
  464    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  465    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  466    )
  467  .
  468  /*------------------------------------------------------------------------*/
  469  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  470  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  471      {"||" Unary<Op> AndExpr<Op,R>
  472        (. OutOp := MakeOp(zcOr,[L,R]);
  473           L := OutOp; .)
  474      }
  475  .
  476  
  477  
  478  /*------------------------------------------------------------------------*/
  479  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  480  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  481      {"&&" Unary<Op> BitOrExpr<Op,R>
  482        (. OutOp := MakeOp(zcAnd,[L,R]);
  483           L := OutOp; .)
  484      }
  485  .
  486  /*------------------------------------------------------------------------*/
  487  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  488  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  489  .
  490  /*------------------------------------------------------------------------*/
  491  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  492  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  493  .
  494  /*------------------------------------------------------------------------*/
  495  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  496  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  497  .
  498  /*------------------------------------------------------------------------*/
  499  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  500  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  501    {( "!="   (. Kind := zcCompNE; .)
  502     | "=="   (. Kind := zcCompEQ; .)
  503     )
  504     Unary<Op> RelExpr<Op,R>
  505           (. OutOp := MakeOp(Kind,[L,R]);
  506              L := OutOp;
  507           .)
  508    }
  509  .
  510  /*------------------------------------------------------------------------*/
  511  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  512  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  513    { ( "<"       (. Kind := zcCompLT; .)
  514      | ">"       (. Kind := zcCompGT; .)
  515      | "<="      (. Kind := zcCompLE; .)
  516      | ">="      (. Kind := zcCompGE; .)
  517       )
  518      Unary<Op> ShiftExpr<Op,R>
  519           (. OutOp := MakeOp(Kind,[L,R]);
  520              L := OutOp;
  521           .)
  522    }
  523  .
  524  /*------------------------------------------------------------------------*/
  525  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  526  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  527  .
  528  /*------------------------------------------------------------------------*/
  529  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  530  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  531      {( "+"    (. Kind := zcPlus; .)
  532       | "-"    (. Kind := zcMinus; .)
  533       ) Unary<Op> MulExpr<Op,R>
  534           (. OutOp := MakeOp(Kind,[L,R]);
  535              L := OutOp;
  536           .)
  537      }
  538  .
  539  /*------------------------------------------------------------------------*/
  540  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp,Op : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  541  =       (. OutOp := InOp; .)
  542    { ("*"      (. Kind := zcMul; .)
  543      | "/"     (. Kind := zcDiv; .)
  544      | "%"
  545      ) Unary<Tmp>
  546           (. OutOp := MakeOp(Kind,[InOp,Tmp]);
  547              InOp := OutOp;
  548           .)
  549      }
  550  .
  551  /*------------------------------------------------------------------------*/
  552  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  553  =       (. LastOp := nil; .)
  554    {
  555      (
  556        (* "+" | *)
  557        "-"       (. Kind := zcNegate; .)
  558        (* | "!" | "~" | "*" | "++" | "--" *)
  559      )   (. Tmp := MakeOp(Kind);
  560             if LastOp<>nil then
  561               LastOp.Children.Add(Tmp);
  562             LastOp := Tmp;
  563          .)
  564    }
  565    Primary<Tmp>
  566      (. if LastOp<>nil then
  567         begin
  568           LastOp.Children.Add(Tmp);
  569           OutOp := LastOp;
  570         end else
  571           OutOp := Tmp;
  572      .)
  573  .
  574  /*------------------------------------------------------------------------*/
  575  Primary<var OutOp : TZcOp>         (. var Op : TZcOp; .)
  576  =            (. OutOp := nil; .)
  577    ( ident    (. OutOp := MakeOp(zcIdentifier,LexString); .)
  578    | Literal  (. OutOp := MakeOp(zcConst,StrToFloat(LexString)); .)
  579    | "(" Expr<OutOp> ")"
  580  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  581      | "float"  | "int"    | "long" | "object"  | "sbyte"
  582      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  583      ) "." ident *)
  584    )
  585  
  586    {
  587  /*  "++" | "--" | "->" ident
  588    | */
  589    "." ident (.
  590        Assert(OutOp.Kind=zcIdentifier);
  591        OutOp.Id := OutOp.Id + '.' + LexString;
  592      .)
  593    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  594             OutOp.Kind:=zcFuncCall;
  595           .)
  596          [Argument<Op> (. OutOp.Children.Add(Op); .)
  597            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  598            }
  599          ]
  600      ")"
  601    }
  602  .
  603  /*------------------------------------------------------------------------*/
  604  Literal
  605  = intCon | realCon | stringCon | "true" | "false" | "null"
  606  .
  607  
  608  END Zc.

    1 LL(1) error
   11 warnings

